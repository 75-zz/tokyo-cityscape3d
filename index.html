<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Tokyo 3D — Pastel City Hunt (OSM + Three.js)</title>
  <style>
    :root{
      --bg:#f6f7fb; --ink:#0b0f14; --glass:rgba(255,255,255,.7); --line:rgba(0,0,0,.08);
      --btn:#ffffff; --btn-line:#d7dce6; --accent:#6aa9ff; --accent2:#ff9ecb; --accent3:#88e1a1;
    }
    html, body { margin: 0; height: 100%; overflow: hidden; background: var(--bg); color: var(--ink); }
    #app { position: fixed; inset: 0; }
    #hud { position: fixed; left: 12px; bottom: 12px; color: var(--ink); font: 12px/1.4 system-ui, "Noto Sans JP", sans-serif; background: var(--glass); border: 1px solid var(--line); padding: 8px 10px; border-radius: 10px; user-select: none; backdrop-filter: blur(8px); z-index:5; }
    #ui { position: fixed; right: 12px; top: 12px; display: flex; gap: 8px; flex-wrap: wrap; z-index: 6; }
    #ui button { background:var(--btn); color:var(--ink); border:1px solid var(--btn-line); padding:8px 12px; border-radius:10px; cursor:pointer; font:12px/1.2 system-ui; box-shadow: 0 1px 0 rgba(0,0,0,.03); }
    #ui button:hover{ filter: brightness(0.98); }
    #tooltip { position: fixed; pointer-events:none; color:var(--ink); background:var(--glass); padding:6px 8px; border-radius:8px; font:12px/1.3 system-ui; transform: translate(-50%,-130%); opacity:0; transition:opacity .12s; border:1px solid var(--line); backdrop-filter: blur(8px); z-index:6; }
    #warn { position: fixed; inset: 12px 12px auto 12px; background: var(--glass); color: var(--ink); border: 1px solid var(--line); padding: 10px 12px; border-radius: 12px; font: 12px/1.5 system-ui, "Noto Sans JP", sans-serif; z-index: 7; display:none; backdrop-filter: blur(8px); }
    #warn strong { color:#4c8dff; }

    /* Overlays */
    .overlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:10; }
    .sheet{ width:min(620px, 94vw); background:var(--glass); border:1px solid var(--line); border-radius:16px; padding:16px; backdrop-filter: blur(10px); box-shadow: 0 20px 60px rgba(0,0,0,.08); }
    .row{ display:flex; gap:12px; align-items:center; }
    .space{ height:12px; }
    .title{ font: 600 16px/1.2 system-ui, "Noto Sans JP"; }
    .muted{ color:#4b5563; font-size:12px; }
    .btn{ background:var(--btn); border:1px solid var(--btn-line); border-radius:10px; padding:8px 12px; cursor:pointer; }
    .btn.primary{ background:linear-gradient(135deg,var(--accent),var(--accent2)); color:white; border:none; }
    .btn.flat{ background:transparent; border: none; color:#1f2937; text-decoration: underline; }
    .grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(160px,1fr)); gap:12px; }
    .card{ background:var(--btn); border:1px solid var(--btn-line); border-radius:12px; padding:10px; text-align:center; display:flex; flex-direction:column; align-items:center; gap:6px; }
    .card .c3d{ width: 140px; height: 110px; border-radius: 10px; overflow: hidden; border:1px solid var(--btn-line); background: #fff; }

    /* Mobile D-Pad */
    #pad { position: fixed; left: 12px; bottom: 12px; width: 120px; height: 120px; z-index: 6; display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; opacity: .95; }
    .padbtn { background: var(--glass); border:1px solid var(--btn-line); border-radius: 12px; touch-action: none; user-select: none; height: 36px; display:flex; align-items:center; justify-content:center; font: 600 14px/1 system-ui; }
    .padbtn:active{ filter: brightness(.96); }
    .padbtn.empty{ visibility: hidden; }

    /* 3D avatars in overlays */
    .c3d-battle, .c3d-result { width: 180px; height: 140px; border-radius: 12px; border:1px solid var(--btn-line); background:#fff; overflow:hidden; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="app"></div>
  <div id="ui">
    <button data-spot="tokyo">東京駅</button>
    <button data-spot="shinjuku">新宿</button>
    <button data-spot="shibuya">渋谷</button>
    <button data-spot="odaiba">お台場</button>
    <button id="refresh">再取得</button>
    <button id="spawn">新規スポーン</button>
    <button id="dex">図鑑</button>
  </div>
  <div id="hud">Pastel City Hunt｜データ: OpenStreetMap / Overpass API</div>
  <div id="tooltip"></div>
  <div id="warn"></div>

  <!-- Mobile D-Pad -->
  <div id="pad">
    <div class="padbtn empty"></div>
    <div class="padbtn" data-dir="f">▲</div>
    <div class="padbtn empty"></div>
    <div class="padbtn" data-dir="l">◀</div>
    <div class="padbtn" data-dir="b">▼</div>
    <div class="padbtn" data-dir="r">▶</div>
    <div class="padbtn empty"></div>
    <div class="padbtn" data-dir="s">⟲</div>
    <div class="padbtn empty"></div>
  </div>

  <!-- Battle Overlay -->
  <div id="battle" class="overlay">
    <div class="sheet">
      <div class="row"><div class="title">バトル開始！</div><div style="flex:1"></div><button class="btn flat" id="closeBattle">閉じる</button></div>
      <div class="space"></div>
      <div class="row">
        <div class="c3d-battle" id="enemyAvatar"></div>
        <div style="flex:1">
          <div><strong id="enemyName">???</strong></div>
          <div class="muted">HP: <span id="enemyHP">--</span></div>
          <div class="space"></div>
          <div class="row">
            <button class="btn primary" id="attackBtn">こうげき</button>
            <button class="btn" id="runBtn">にげる</button>
          </div>
        </div>
      </div>
      <div class="space"></div>
      <div class="muted" id="battleLog">…</div>
    </div>
  </div>

  <!-- Result Overlay -->
  <div id="result" class="overlay">
    <div class="sheet" style="text-align:center">
      <div class="title">GET!!</div>
      <div class="space"></div>
      <div class="c3d-result" id="resultAvatar"></div>
      <div class="space"></div>
      <div><strong id="resultName">---</strong></div>
      <div class="space"></div>
      <button class="btn primary" id="keepBtn">図鑑に登録</button>
      <button class="btn" id="continueBtn">つづける</button>
    </div>
  </div>

  <!-- Dex Overlay -->
  <div id="dexOverlay" class="overlay">
    <div class="sheet">
      <div class="row"><div class="title">図鑑</div><div style="flex:1"></div><button class="btn flat" id="closeDex">閉じる</button></div>
      <div class="space"></div>
      <div id="dexGrid" class="grid"></div>
    </div>
  </div>

  <script>
    // 注意喚起
    (function(){
      const warn = document.getElementById('warn');
      const importMapSupported = ('supports' in HTMLScriptElement && HTMLScriptElement.supports('importmap'));
      let msgs = [];
      if (location.protocol === 'file:') {
        msgs.push('現在 <strong>file://</strong> で開いています。環境によっては動作しないことがあります。<br>うまくいかない場合は、<code>python -m http.server</code> 等で http://localhost:8000 から開いてください。');
      }
      if (!importMapSupported) msgs.push('このブラウザは <strong>importmap</strong> に対応していない可能性があります。最新ブラウザを推奨。');
      msgs.push('このアプリは <strong>インターネット接続</strong> と <strong>Overpass API</strong> が必要です。');
      if (msgs.length) { warn.innerHTML = msgs.join('<hr style="border:none;border-top:1px solid var(--line);margin:8px 0">'); warn.style.display='block'; setTimeout(()=>warn.style.display='none', 8000); }
    })();
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // ---- Config ----
    const RADIUS_M = 800; // OSMの取得半径
    const CENTER_PRESETS = {
      tokyo:   [139.767125, 35.681236], // 東京駅
      shinjuku:[139.700556, 35.689722],
      shibuya: [139.702148, 35.659516],
      odaiba:  [139.775,    35.625]
    };
    let center = CENTER_PRESETS.tokyo.slice();

    // モンスター定義（IP回避のオリジナル）
    const MONS = [
      { key:'fluffin', name:'フラッフィン', color:'#ffd1e6', power:[8,14] },
      { key:'sparkid', name:'スパーキッド', color:'#cfe6ff', power:[10,16] },
      { key:'mossie',  name:'モッシー',     color:'#dff6df', power:[7,12] },
      { key:'embero',  name:'エンベロ',     color:'#ffe3c3', power:[9,15] },
      { key:'glacio',  name:'グラシオ',     color:'#e6f3ff', power:[11,17] }
    ];

    // ---- Three.js setup ----
    const container = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#f6f7fb');

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 8000);
    camera.position.set(0, 540, 1100);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.minDistance = 50;
    controls.maxDistance = 4000;

    // ライト
    scene.add(new THREE.AmbientLight(0xffffff, 0.9));
    const sun = new THREE.DirectionalLight(0xffffff, 0.8); sun.position.set(800, 1500, 600); scene.add(sun);

    // 地面
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(4000, 4000), new THREE.MeshStandardMaterial({ color: 0xf0f4ff, roughness: 1 }));
    ground.rotation.x = -Math.PI / 2; ground.position.y = 0; scene.add(ground);

    // グリッド
    const grid = new THREE.GridHelper(4000, 80, 0xbed2ff, 0xdee7ff); grid.position.y = 0.02; scene.add(grid);

    const city = new THREE.Group(); scene.add(city);
    const spawns = new THREE.Group(); scene.add(spawns);

    // Raycast
    const tooltip = document.getElementById('tooltip');
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // ---- Utils: WebMercator ----
    const DEG2RAD = Math.PI / 180; const R = 6378137;
    function lonLatToMeters(lon, lat){ const x = R * lon * DEG2RAD; const y = R * Math.log(Math.tan(Math.PI/4 + (lat*DEG2RAD)/2)); return [x, y]; }
    function localXY(lon, lat, originLon, originLat){ const [ox, oy] = lonLatToMeters(originLon, originLat); const [x, y] = lonLatToMeters(lon, lat); return [x - ox, -(y - oy)]; }

    // ---- Overpass fetch ----
    async function fetchBuildings(lon, lat, radiusMeters){
      const dLat = (radiusMeters / 111320);
      const dLon = radiusMeters / (111320 * Math.cos(lat * DEG2RAD));
      const s = lat - dLat, w = lon - dLon, n = lat + dLat, e = lon + dLon;
      const query = `\n[out:json][timeout:25];\n(\n  way["building"](${s},${w},${n},${e});\n  relation["building"](${s},${w},${n},${e});\n);\nout body;\n>;\nout skel qt;`;
      const url = 'https://overpass-api.de/api/interpreter';
      const res = await fetch(url, { method:'POST', body: query, headers: { 'Content-Type': 'text/plain' } });
      if(!res.ok) throw new Error('Overpass API error ' + res.status);
      return res.json();
    }

    // ---- Build meshes from OSM ----
    function buildCityFromOSM(osm){
      city.clear(); spawns.clear();
      const nodes = new Map();
      for(const el of osm.elements){ if(el.type === 'node') nodes.set(el.id, el); }
      const palette = ['#cfe0ff','#d8f0ff','#ffe7f3','#e7ffef','#fff5cc'];

      function heightFromTags(tags){
        if(!tags) return 16 + Math.random()*48;
        if(tags?.height){ const m = String(tags.height).match(/([0-9.]+)/); if(m) return parseFloat(m[1]); }
        if(tags?.["building:levels"]) return parseFloat(tags["building:levels"]) * 3 + 3;
        return 12 + Math.random()*40;
      }

      for(const el of osm.elements){
        if(el.type !== 'way' || !el.tags?.building) continue;
        const pts = [];
        for(const nid of el.nodes){ const nd = nodes.get(nid); if(!nd) { pts.length=0; break; } pts.push(localXY(nd.lon, nd.lat, center[0], center[1])); }
        if(pts.length < 3) continue;
        const first = pts[0], last = pts[pts.length-1];
        if(first[0] !== last[0] || first[1] !== last[1]) pts.push(first);
        const shape = new THREE.Shape(); shape.moveTo(pts[0][0], pts[0][1]); for(let i=1;i<pts.length;i++) shape.lineTo(pts[i][0], pts[i][1]);
        const h = heightFromTags(el.tags);
        const geom = new THREE.ExtrudeGeometry(shape, { depth: h, bevelEnabled: false });
        geom.rotateX(-Math.PI/2); geom.computeVertexNormals();
        const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(palette[(Math.random()*palette.length)|0]), metalness: 0.05, roughness: 0.9, emissive: 0xffffff, emissiveIntensity: 0.05 });
        const mesh = new THREE.Mesh(geom, mat); mesh.position.y = 0; mesh.castShadow = false; mesh.receiveShadow = false; mesh.userData = { tags: el.tags, height: h };
        city.add(mesh);
      }

      spawnMonsters();
    }

    // ---- Monster models (more details) ----
    function makeMonsterModel(mon){
      const g = new THREE.Group();
      g.userData.mon = mon;
      const toon = (c)=> new THREE.MeshToonMaterial({ color: new THREE.Color(c) });
      const mainMat = toon(mon.color);
      const white = toon('#ffffff');
      const dark = toon('#1f2937');

      const addEye = (x,y,z,s=1)=>{
        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.9*s, 16, 16), dark);
        eye.position.set(x,y,z); g.add(eye);
      };

      const addBlush = (x,y,z)=>{
        const b = new THREE.Mesh(new THREE.SphereGeometry(0.8, 12, 12), toon('#ffb5d1'));
        b.position.set(x,y,z); b.scale.set(1.4,0.6,1.2); g.add(b);
      };

      switch(mon.key){
        case 'fluffin': {
          const body = new THREE.Mesh(new THREE.SphereGeometry(8, 24, 24), mainMat);
          const earL = new THREE.Mesh(new THREE.ConeGeometry(3.2, 5.5, 12), mainMat);
          const earR = earL.clone(); earL.material.side = earR.material.side = THREE.DoubleSide;
          earL.position.set(-4, 10, 0); earL.rotation.z = 0.2; earR.position.set(4, 10, 0); earR.rotation.z = -0.2;
          const footL = new THREE.Mesh(new THREE.SphereGeometry(2.2, 16, 16), mainMat); const footR = footL.clone();
          footL.position.set(-3, -7.5, 2); footR.position.set(3, -7.5, 2);
          addEye(-2.2, 3.2, 7.4); addEye(2.2, 3.2, 7.4); addBlush(-3.5, 1.8, 6.6); addBlush(3.5, 1.8, 6.6);
          g.add(body, earL, earR, footL, footR);
          g.userData.anim = 'float';
          break;
        }
        case 'sparkid': {
          const body = new THREE.Mesh(new THREE.BoxGeometry(12, 9, 10), mainMat);
          const ant = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 7, 12), white);
          const tip = new THREE.Mesh(new THREE.SphereGeometry(1.6, 16, 16), white);
          const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 5, 10), mainMat);
          const armR = armL.clone(); armL.position.set(-7, 0.5, 0); armR.position.set(7, 0.5, 0); armL.rotation.z = 1.2; armR.rotation.z = -1.2;
          ant.position.set(0, 7.5, 0); tip.position.set(0, 11.5, 0);
          addEye(-2.8, 2.5, 5.2); addEye(2.8, 2.5, 5.2);
          g.add(body, ant, tip, armL, armR);
          g.userData.parts = { ant, tip };
          g.userData.anim = 'antenna';
          break;
        }
        case 'mossie': {
          const body = new THREE.Mesh(new THREE.SphereGeometry(7.5, 24, 24), mainMat);
          const tail = new THREE.Mesh(new THREE.ConeGeometry(3.2, 6.5, 12), mainMat); tail.material.side = THREE.DoubleSide; tail.rotation.x = Math.PI; tail.position.set(0, -7, -1);
          const wingL = new THREE.Mesh(new THREE.ConeGeometry(2.2, 8, 12), white); const wingR = wingL.clone();
          wingL.material.side = wingR.material.side = THREE.DoubleSide; wingL.rotation.z =  1.1; wingL.position.set(-7, 2, 0); wingR.rotation.z = -1.1; wingR.position.set(7, 2, 0);
          const leaf = new THREE.Mesh(new THREE.CapsuleGeometry(1.5, 3.5, 6, 10), toon('#a0e6b6')); leaf.rotation.z = 0.5; leaf.position.set(-1.2, 8.5, -1);
          addEye(-2.1, 2.6, 6.7); addEye(2.1, 2.6, 6.7);
          g.add(body, tail, wingL, wingR, leaf);
          g.userData.parts = { wingL, wingR };
          g.userData.anim = 'flap';
          break;
        }
        case 'embero': {
          const body = new THREE.Mesh(new THREE.SphereGeometry(7.5, 24, 24), mainMat);
          const f1 = new THREE.Mesh(new THREE.ConeGeometry(2.2, 7, 8), toon('#ffdcb3'));
          const f2 = f1.clone(); const f3 = f1.clone(); f1.material.side = f2.material.side = f3.material.side = THREE.DoubleSide;
          f1.position.set(0, 9.5, 0); f2.position.set(-2.6, 8.8, -1.2); f2.rotation.z = 0.4; f3.position.set(2.6, 8.8, -1.2); f3.rotation.z = -0.4;
          const tail = new THREE.Mesh(new THREE.ConeGeometry(1.8, 5.5, 8), toon('#ffb899')); tail.rotation.x = Math.PI; tail.position.set(0, -7, -1.5);
          addEye(-2.2, 2.4, 6.7); addEye(2.2, 2.4, 6.7);
          g.add(body, f1, f2, f3, tail);
          g.userData.parts = { f1, f2, f3 };
          g.userData.anim = 'flicker';
          break;
        }
        case 'glacio': {
          const body = new THREE.Mesh(new THREE.IcosahedronGeometry(7.5, 0), mainMat);
          const shard1 = new THREE.Mesh(new THREE.ConeGeometry(2, 6, 6), toon('#e7f2ff'));
          const shard2 = shard1.clone(); shard1.material.side = shard2.material.side = THREE.DoubleSide;
          shard1.position.set(-4, -5, -2); shard1.rotation.x = -0.6; shard2.position.set(4, -5, -2); shard2.rotation.x = -0.6;
          addEye(-2.0, 1.8, 6.8); addEye(2.0, 1.8, 6.8);
          g.add(body, shard1, shard2);
          g.userData.parts = { body };
          g.userData.anim = 'spin';
          break;
        }
      }

      // 口（全員共通、前面に小さなリング）
      const mouth = new THREE.Mesh(new THREE.TorusGeometry(1.2, 0.35, 8, 24), dark); mouth.rotation.x = Math.PI/2; mouth.position.set(0, 0.2, 7.2); g.add(mouth);

      // 足場リング
      const ring = new THREE.Mesh(new THREE.TorusGeometry(14, 1.5, 8, 32), new THREE.MeshStandardMaterial({ color: '#ffffff', emissive: 0xffffff, emissiveIntensity: 0.2 }));
      ring.rotation.x = Math.PI/2; g.add(ring);

      // エッジ線で視認性UP
      const outlines = [];
      g.traverse(obj=>{ if(obj.isMesh){ const eg = new THREE.EdgesGeometry(obj.geometry, 20); outlines.push(new THREE.LineSegments(eg, new THREE.LineBasicMaterial({ color: 0x2f3947, transparent:true, opacity:0.32 }))); } });
      outlines.forEach(ls=>g.add(ls));

      g.scale.set(2.4, 2.4, 2.4);
      return g;
    }

    // ---- Spawns ----
    function spawnMonsters(count = 10){
      spawns.clear();
      const area = 900;
      for(let i=0;i<count;i++){
        const mon = MONS[(Math.random()*MONS.length)|0];
        const g = makeMonsterModel(mon);
        const x = (Math.random()-0.5)*2*area; const z = (Math.random()-0.5)*2*area; const y = getTopHeightAt(x, z) + 6;
        g.position.set(x, y, z); g.rotation.y = Math.random()*Math.PI*2; g.userData.type = 'spawn';
        spawns.add(g);
      }
    }

    function getTopHeightAt(x, z){
      const rc = new THREE.Raycaster(new THREE.Vector3(x, 5000, z), new THREE.Vector3(0, -1, 0));
      const hits = rc.intersectObjects(city.children, false); return hits.length ? hits[0].point.y : 0;
    }

    // ---- Battle state ----
    const battleEl = document.getElementById('battle');
    const enemyNameEl = document.getElementById('enemyName');
    const enemyHPEl = document.getElementById('enemyHP');
    const battleLogEl = document.getElementById('battleLog');
    const attackBtn = document.getElementById('attackBtn');
    const runBtn = document.getElementById('runBtn');
    const closeBattle = document.getElementById('closeBattle');

    let currentEnemy = null; let enemyHP = 0; let myHP = 30;

    function openBattle(mon){
      currentEnemy = mon; enemyHP = 20 + Math.floor(Math.random()*15); myHP = 30;
      enemyNameEl.textContent = mon.name; enemyHPEl.textContent = enemyHP;
      ensureCard(enemyAvatar, mon);
      battleLogEl.textContent = '野生の ' + mon.name + ' があらわれた！';
      battleEl.style.display = 'flex';
    }

    function closeBattleUI(){ battleEl.style.display = 'none'; }

    attackBtn?.addEventListener('click', ()=>{
      if(!currentEnemy) return;
      const dmg = randInt(...currentEnemy.power);
      enemyHP = Math.max(0, enemyHP - dmg);
      enemyHPEl.textContent = enemyHP;
      battleLogEl.textContent = `${currentEnemy.name} に ${dmg} ダメージ！`;
      if(enemyHP === 0){ setTimeout(()=> openResult(currentEnemy), 400); battleEl.style.display = 'none'; return; }
      const counter = randInt(3,8); myHP = Math.max(0, myHP - counter);
      battleLogEl.textContent += ` / こうげきをうけた！ (${counter})`;
    });

    runBtn?.addEventListener('click', ()=>{ battleLogEl.textContent = 'にげた！'; setTimeout(closeBattleUI, 250); });
    closeBattle?.addEventListener('click', closeBattleUI);

    // ---- Result ----
    const resultEl = document.getElementById('result');
    const resultName = document.getElementById('resultName');
    const keepBtn = document.getElementById('keepBtn');
    const continueBtn = document.getElementById('continueBtn');
    let captured = null;

    function openResult(mon){ captured = mon; resultName.textContent = mon.name; ensureCard(resultAvatar, mon); resultEl.style.display='flex'; }
    keepBtn?.addEventListener('click', ()=>{ if(captured){ addToDex(captured); } resultEl.style.display='none'; });
    continueBtn?.addEventListener('click', ()=>{ resultEl.style.display='none'; });

    // ---- Dex (localStorage) ----
    const DEX_KEY = 'pastel_city_dex_v2';
    const dexOverlay = document.getElementById('dexOverlay');
    const dexGrid = document.getElementById('dexGrid');
    const closeDexBtn = document.getElementById('closeDex');
    function loadDex(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY) || '[]'); }catch{ return []; } }
    function saveDex(list){ localStorage.setItem(DEX_KEY, JSON.stringify(list)); }
    function addToDex(mon){ const list = loadDex(); list.push({ key: mon.key, name: mon.name, color: mon.color, ts: Date.now() }); saveDex(list); showDex(); }
    function showDex(){
      const list = loadDex(); dexGrid.innerHTML = '';
      if(list.length===0){ dexGrid.innerHTML = '<div class="muted">まだ何も捕まえていません。</div>'; }
      else{
        for(const it of list){
          const d = document.createElement('div'); d.className='card';
          const c = document.createElement('div'); c.className='c3d'; d.appendChild(c);
          const name = document.createElement('div'); name.innerHTML = `<strong>${it.name}</strong>`; d.appendChild(name);
          const time = document.createElement('div'); time.className='muted'; time.textContent = new Date(it.ts).toLocaleString(); d.appendChild(time);
          dexGrid.appendChild(d);
          ensureCard(c, it, true);
        }
      }
      dexOverlay.style.display='flex';
    }
    closeDexBtn?.addEventListener('click', ()=> dexOverlay.style.display='none');
    document.getElementById('dex').addEventListener('click', showDex);

    // ---- Card renderer (3D monster in UI boxes) ----
    const cardScenes = new Set();
    function ensureCard(container, mon, small=false){
      container.innerHTML = '';
      const scene = new THREE.Scene(); scene.background = new THREE.Color('#ffffff');
      const cam = new THREE.PerspectiveCamera(38, container.clientWidth/container.clientHeight, 0.01, 2000);
      const light = new THREE.HemisphereLight(0xffffff, 0xdde5ff, 1); scene.add(light);
      const dlight = new THREE.DirectionalLight(0xffffff, .8); dlight.position.set(1,2,1); scene.add(dlight);
      const model = makeMonsterModel(mon);
      scene.add(model);

      // フィット：モデルのバウンディングボックスでカメラ距離と中心を調整
      const box = new THREE.Box3().setFromObject(model);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      model.position.sub(center); // 原点中心に
      const vFov = THREE.MathUtils.degToRad(cam.fov);
      const fitH = (size.y/2) / Math.tan(vFov/2);
      const fitW = (size.x/2) / (Math.tan(vFov/2) * cam.aspect);
      const dist = Math.max(fitH, fitW) * 1.35 + size.z*0.2;
      cam.position.set(0, 0, dist);
      cam.near = Math.max(0.01, dist/50); cam.far = dist*50; cam.updateProjectionMatrix();
      cam.lookAt(0, 0, 0);

      const r = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'low-power' });
      r.setPixelRatio( Math.min(devicePixelRatio, 1.5) );
      r.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(r.domElement);
      const entry = { r, scene, cam, model, mon };
      cardScenes.add(entry);

      // クリックで鳴き声
      r.domElement.addEventListener('pointerdown', ()=> playCry(mon));

      // Resize observer
      const ro = new ResizeObserver(()=>{
        r.setSize(container.clientWidth, container.clientHeight);
        cam.aspect = container.clientWidth/container.clientHeight; cam.updateProjectionMatrix();
        const vFov = THREE.MathUtils.degToRad(cam.fov);
        const fitH = (size.y/2) / Math.tan(vFov/2);
        const fitW = (size.x/2) / (Math.tan(vFov/2) * cam.aspect);
        const dist = Math.max(fitH, fitW) * 1.35 + size.z*0.2;
        cam.position.set(0, 0, dist); cam.near=Math.max(0.01, dist/50); cam.far=dist*50; cam.updateProjectionMatrix();
      });
      ro.observe(container);

      // 初回だけ描画（回転なしの静止表示）
      r.render(scene, cam);
    }

    // ---- Movement: keyboard & on-screen D-Pad ----
    const move = { f:false, b:false, l:false, r:false, s:false };
    const setMove = (k,val)=>{ if(k in move) move[k]=val; };
    const keyMap = { 'KeyW':'f','ArrowUp':'f','KeyS':'b','ArrowDown':'b','KeyA':'l','ArrowLeft':'l','KeyD':'r','ArrowRight':'r','ShiftLeft':'s','ShiftRight':'s' };
    addEventListener('keydown', (e)=>{ const k = keyMap[e.code]; if(k){ setMove(k,true); } });
    addEventListener('keyup', (e)=>{ const k = keyMap[e.code]; if(k){ setMove(k,false); } });

    // Touch buttons
    document.getElementById('pad').addEventListener('pointerdown', (e)=>{ const b = e.target.closest('.padbtn'); if(!b) return; const d=b.dataset.dir; if(!d) return; setMove(d,true); b.setPointerCapture(e.pointerId); });
    document.getElementById('pad').addEventListener('pointerup', (e)=>{ const b = e.target.closest('.padbtn'); if(!b) return; const d=b.dataset.dir; if(!d) return; setMove(d,false); });
    document.getElementById('pad').addEventListener('pointercancel', (e)=>{ for(const k in move) move[k]=false; });
    document.getElementById('pad').addEventListener('pointerleave', (e)=>{ for(const k in move) move[k]=false; });

    // ---- Load & build ----
    async function loadAndBuild(){
      setStatus('OSM建物取得中…');
      try{ const data = await fetchBuildings(center[0], center[1], RADIUS_M); buildCityFromOSM(data); fitCamera(); setStatus('完了: ' + city.children.length + ' 棟 / スポーン: ' + spawns.children.length); }
      catch(err){ console.error(err); setStatus('取得失敗: ' + err.message); }
    }

    function fitCamera(){ controls.target.set(0,0,0); camera.position.set(0, 540, 1100); controls.update(); }

    document.getElementById('ui').addEventListener('click', (e)=>{
      const btn = e.target.closest('button'); if(!btn) return;
      if(btn.id === 'refresh'){ loadAndBuild(); return; }
      if(btn.id === 'spawn'){ spawnMonsters(10); setStatus('スポーン作成: ' + spawns.children.length); return; }
      if(btn.dataset.spot){ const key = btn.dataset.spot; if(CENTER_PRESETS[key]){ center = CENTER_PRESETS[key].slice(); loadAndBuild(); } }
    });

    function findSpawnGroup(obj){ let cur = obj; while(cur && cur.parent){ if(cur.userData && cur.userData.type==='spawn') return cur; cur = cur.parent; } return null; }

    // Click interactions
    addEventListener('pointerdown', (e)=>{
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left)/rect.width)*2 - 1; mouse.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hitsSpawn = raycaster.intersectObjects(spawns.children, true);
      if(hitsSpawn.length){ const root = findSpawnGroup(hitsSpawn[0].object); if(root){ playCry(root.userData.mon); openBattle(root.userData.mon); } return; }
      const hitB = raycaster.intersectObjects(city.children, false)[0];
      if(hitB){ const tags = hitB.object.userData.tags || {}; const h = Math.round(hitB.object.userData.height); showTip(e.clientX, e.clientY, `${tags.name? tags.name + ' / ' : ''}高さ: ${h}m`); } else { hideTip(); }
    });

    function showTip(x,y, text){ const t = document.getElementById('tooltip'); t.textContent = text; t.style.left=x+'px'; t.style.top=y+'px'; t.style.opacity=1; }
    function hideTip(){ document.getElementById('tooltip').style.opacity = 0; }

    // Status
    const hud = document.getElementById('hud');
    function setStatus(msg){ hud.textContent = `Pastel City Hunt｜${msg}`; }

    // Resize
    addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    // Animate (main + card scenes)
    const clock = new THREE.Clock();
    ;(function loop(){
      requestAnimationFrame(loop);
      const dt = Math.min(clock.getDelta(), 0.033);

      // Camera move
      const spd = (move.s ? 140 : 70) * dt;
      const f = new THREE.Vector3(); camera.getWorldDirection(f); f.y = 0; f.normalize();
      const r = new THREE.Vector3().crossVectors(f, new THREE.Vector3(0,1,0)).normalize();
      const mv = new THREE.Vector3();
      if(move.f) mv.add(f); if(move.b) mv.addScaledVector(f, -1); if(move.r) mv.add(r); if(move.l) mv.addScaledVector(r, -1);
      if(mv.lengthSq()>0){ mv.normalize().multiplyScalar(spd); camera.position.add(mv); controls.target.add(mv); }

      // Spawn anims
      const t = performance.now()/1000;
      spawns.children.forEach((g,i)=>{
        g.position.y = 12 + Math.sin(t*1.6 + i)*1.5;
        g.rotation.y += 0.01;
        const mon = g.userData.mon; const parts = g.userData.parts||{};
        if(mon?.key==='mossie' && parts.wingL && parts.wingR){ const a = Math.sin(t*6 + i)*0.5 + 0.6; parts.wingL.rotation.z =  1.1 + a*0.25; parts.wingR.rotation.z = -1.1 - a*0.25; }
        if(mon?.key==='sparkid' && parts.ant && parts.tip){ parts.ant.rotation.z = Math.sin(t*4 + i)*0.15; parts.tip.position.y = 11.5 + Math.sin(t*3 + i)*0.4; }
        if(mon?.key==='embero' && parts.f1){ const k = Math.sin(t*5 + i)*0.08; parts.f1.rotation.z = k; if(parts.f2) parts.f2.rotation.z = 0.4 + k; if(parts.f3) parts.f3.rotation.z = -0.4 - k; }
        if(mon?.key==='glacio' && parts.body){ parts.body.rotation.y += 0.01; }
      });

      controls.update(); renderer.render(scene, camera);

      // Render small card scenes
      cardScenes.forEach(({r, scene, cam})=>{ r.render(scene, cam); });
    })();

    // Helpers
    function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

    // ---- Audio（鳴き声） ----
    let ACTX = null;
    function ensureAudio(){ if(!ACTX){ const C = window.AudioContext || window.webkitAudioContext; if(C){ ACTX = new C(); } } if(ACTX?.state === 'suspended'){ ACTX.resume(); } }
    function beep(freq=600, dur=0.12, type='triangle', vol=0.03){ if(!ACTX) return; const t=ACTX.currentTime; const o=ACTX.createOscillator(); const g=ACTX.createGain(); o.type=type; o.frequency.setValueAtTime(freq, t); g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(vol, t+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t+dur); o.connect(g).connect(ACTX.destination); o.start(t); o.stop(t+dur); }
    function playCry(mon){ ensureAudio(); if(!ACTX) return; switch(mon.key){
      case 'fluffin': beep(680,0.11,'triangle',0.03); setTimeout(()=>beep(920,0.09,'triangle',0.025),90); break;
      case 'sparkid': beep(520,0.08,'square',0.025); setTimeout(()=>beep(1040,0.06,'square',0.02),70); break;
      case 'mossie':  beep(600,0.1,'sine',0.02); setTimeout(()=>beep(760,0.12,'sine',0.02),110); break;
      case 'embero':  beep(440,0.08,'sawtooth',0.02); setTimeout(()=>beep(660,0.08,'triangle',0.02),80); break;
      case 'glacio':  beep(840,0.09,'sine',0.02); setTimeout(()=>beep(700,0.07,'sine',0.02),70); break;
    } }

    // 初回ユーザー操作でAudioContextを起動
    addEventListener('pointerdown', ensureAudio, { once: true });

    // Boot
    loadAndBuild();
  </script>
</body>
</html>
