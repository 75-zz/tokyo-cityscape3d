<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tokyo 3D (Free, OSM + Overpass + Three.js)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #0b0f14; }
    #app { position: fixed; inset: 0; }
    #hud { position: fixed; left: 12px; bottom: 12px; color: #d9e3f0; font: 12px/1.4 system-ui, "Noto Sans JP", sans-serif; background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.1); padding: 8px 10px; border-radius: 8px; user-select: none; }
    #ui { position: fixed; right: 12px; top: 12px; display: flex; gap: 8px; flex-wrap: wrap; z-index: 3; }
    #ui button { background:#111826; color:#d9e3f0; border:1px solid #334155; padding:6px 10px; border-radius:8px; cursor:pointer; font:12px/1.2 system-ui; }
    #ui button:hover{ background:#1f2937; }
    #tooltip { position: fixed; pointer-events:none; color:#fff; background:rgba(0,0,0,.65); padding:6px 8px; border-radius:6px; font:12px/1.3 system-ui; transform: translate(-50%,-130%); opacity:0; transition:opacity .12s; }
    #warn { position: fixed; inset: 12px 12px auto 12px; background: #111827; color: #e5e7eb; border: 1px solid #374151; padding: 10px 12px; border-radius: 10px; font: 12px/1.5 system-ui, "Noto Sans JP", sans-serif; z-index: 5; display:none; }
    #warn strong { color:#93c5fd; }
    a { color:#8cd1ff; }
  </style>
  <!-- Import Map: bare specifiers をCDNに解決させる -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="app"></div>
  <div id="ui">
    <button data-spot="tokyo">東京駅</button>
    <button data-spot="shinjuku">新宿</button>
    <button data-spot="shibuya">渋谷</button>
    <button data-spot="odaiba">お台場</button>
    <button id="refresh">再取得</button>
  </div>
  <div id="hud">データ: OpenStreetMap（Overpass API）/ クリックで高さ表示 / 無料で動作（要: 公開負荷配慮）</div>
  <div id="tooltip"></div>
  <div id="warn"></div>

  <script>
    // 実行ヒント（file:// 直開きや importmap 非対応のブラウザに注意喚起）
    (function(){
      const warn = document.getElementById('warn');
      const importMapSupported = (function(){
        const s = document.createElement('script');
        return 'supports' in HTMLScriptElement && HTMLScriptElement.supports('importmap');
      })();
      let msgs = [];
      if (location.protocol === 'file:') {
        msgs.push('現在 <strong>file://</strong> で開いています。ブラウザや環境によっては動作しないことがあります。<br>うまくいかない場合は、<code>python -m http.server</code> などでローカルサーバ経由（http://localhost:8000）で開いてください。');
      }
      if (!importMapSupported) {
        msgs.push('このブラウザは <strong>importmap</strong> に対応していない可能性があります。Chrome/Edge/Firefox の最新を推奨。');
      }
      msgs.push('このアプリは <strong>インターネット接続</strong> と <strong>Overpass API</strong> へのアクセスが必要です。');
      if (msgs.length) {
        warn.innerHTML = msgs.join('<hr style="border:none;border-top:1px solid #374151;margin:8px 0">');
        warn.style.display = 'block';
        setTimeout(()=>warn.style.display='none', 8000);
      }
    })();
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // ---- Config ----
    const RADIUS_M = 800; // 取得半径（m）…大きくしすぎると重い＆API負荷
    const CENTER_PRESETS = {
      tokyo:   [139.767125, 35.681236], // 東京駅
      shinjuku:[139.700556, 35.689722],
      shibuya: [139.702148, 35.659516],
      odaiba:  [139.775,    35.625]
    };

    let center = CENTER_PRESETS.tokyo.slice();

    // ---- Three.js setup ----
    const container = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f14);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 8000);
    camera.position.set(0, 600, 1200);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.minDistance = 50;
    controls.maxDistance = 4000;

    scene.add(new THREE.AmbientLight(0x8899aa, 0.8));
    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(800, 1500, 600);
    scene.add(sun);

    // ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(4000, 4000),
      new THREE.MeshStandardMaterial({ color: 0x0e141b, roughness: 1 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    // helpers
    const grid = new THREE.GridHelper(4000, 80, 0x203040, 0x142230);
    grid.position.y = 0.02;
    scene.add(grid);

    const city = new THREE.Group();
    scene.add(city);

    // Tooltip & raycaster
    const tooltip = document.getElementById('tooltip');
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let highlighted = null, origMat = null;

    // ---- Utils: WebMercator (EPSG:3857-ish) ----
    const DEG2RAD = Math.PI / 180;
    const R = 6378137;
    function lonLatToMeters(lon, lat){
      const x = R * lon * DEG2RAD;
      const y = R * Math.log(Math.tan(Math.PI/4 + (lat*DEG2RAD)/2));
      return [x, y];
    }
    function localXY(lon, lat, originLon, originLat){
      const [ox, oy] = lonLatToMeters(originLon, originLat);
      const [x, y] = lonLatToMeters(lon, lat);
      // Three.js平面上: x→東, z→南（yが高さ）
      return [x - ox, -(y - oy)];
    }

    // ---- Overpass fetch ----
    async function fetchBuildings(lon, lat, radiusMeters){
      // bbox生成（緯度経度の簡易近似）
      const dLat = (radiusMeters / 111320);
      const dLon = radiusMeters / (111320 * Math.cos(lat * DEG2RAD));
      const s = lat - dLat, w = lon - dLon, n = lat + dLat, e = lon + dLon;

      const query = `\n[out:json][timeout:25];\n(\n  way["building"](${s},${w},${n},${e});\n  relation["building"](${s},${w},${n},${e});\n);\nout body;\n>;\nout skel qt;`;

      const url = 'https://overpass-api.de/api/interpreter';
      const res = await fetch(url, { method:'POST', body: query, headers: { 'Content-Type': 'text/plain' } });
      if(!res.ok) throw new Error('Overpass API error ' + res.status);
      return res.json();
    }

    // ---- Build meshes from OSM ----
    function buildCityFromOSM(osm, originLon, originLat){
      city.clear();
      const nodes = new Map();
      const ways = new Map();
      for(const el of osm.elements){
        if(el.type === 'node') nodes.set(el.id, el);
        if(el.type === 'way') ways.set(el.id, el);
      }
      const palette = [0x9fb3c8, 0xa2aab8, 0xbbc6d6, 0x8aa0b2, 0xb8c7d9];

      function heightFromTags(tags){
        if(!tags) return 20 + Math.random()*60;
        if(tags.height){
          const m = String(tags.height).match(/([0-9.]+)/);
          if(m) return parseFloat(m[1]);
        }
        if(tags["building:levels"]) return parseFloat(tags["building:levels"]) * 3.2 + 3; // 簡易換算
        return 12 + Math.random()*40;
      }

      function addFootprint(nodeIds, tags){
        // クローズ確認
        if(nodeIds.length < 3) return;
        const pts = [];
        for(const nid of nodeIds){
          const nd = nodes.get(nid);
          if(!nd) return; // 欠損
          pts.push(localXY(nd.lon, nd.lat, originLon, originLat));
        }
        // 自動クローズ（wayが未クローズのこともある）
        const first = pts[0], last = pts[pts.length-1];
        if(first[0] !== last[0] || first[1] !== last[1]) pts.push(first);

        // Shapeへ
        const shape = new THREE.Shape();
        shape.moveTo(pts[0][0], pts[0][1]);
        for(let i=1;i<pts.length;i++) shape.lineTo(pts[i][0], pts[i][1]);

        const h = heightFromTags(tags);
        const geom = new THREE.ExtrudeGeometry(shape, { depth: h, bevelEnabled: false });
        // ThreeのExtrudeは+Z方向に伸びるので、Y=高さに合わせるため回転
        geom.rotateX(-Math.PI/2);
        geom.computeVertexNormals();

        const mat = new THREE.MeshStandardMaterial({ color: palette[(Math.random()*palette.length)|0], metalness: 0.1, roughness: 0.85, emissive: 0x0a0f18, emissiveIntensity: 0.2 });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.y = 0;
        mesh.castShadow = false; // 影は負荷になるのでOFF（必要ならON）
        mesh.receiveShadow = false;
        mesh.userData = { tags, height: h };
        city.add(mesh);
      }

      // ways (building)
      for(const el of osm.elements){
        if(el.type === 'way' && el.tags && el.tags.building){
          addFootprint(el.nodes, el.tags);
        }
      }
      // NOTE: relation(multipolygon) は簡略化のため未対応。必要なら追加実装可。
    }

    async function loadAndBuild(){
      setStatus('OSM建物取得中…');
      try{
        const data = await fetchBuildings(center[0], center[1], RADIUS_M);
        buildCityFromOSM(data, center[0], center[1]);
        fitCamera();
        setStatus('完了: ' + city.children.length + ' 棟');
      }catch(err){
        console.error(err);
        setStatus('取得失敗: ' + err.message);
      }
    }

    function fitCamera(){
      // 簡易で街全体が入る距離へ
      controls.target.set(0,0,0);
      camera.position.set(0, 800, 1200);
      controls.update();
    }

    // UI
    document.getElementById('ui').addEventListener('click', (e)=>{
      const btn = e.target.closest('button'); if(!btn) return;
      if(btn.id === 'refresh'){ loadAndBuild(); return; }
      const key = btn.dataset.spot;
      if(key && CENTER_PRESETS[key]){ center = CENTER_PRESETS[key].slice(); loadAndBuild(); }
    });

    // Click highlight
    addEventListener('pointerdown', (e)=>{
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left)/rect.width)*2 - 1;
      mouse.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hit = raycaster.intersectObjects(city.children, false)[0];
      if(highlighted){ highlighted.material = origMat; highlighted = null; origMat = null; }
      if(hit){
        highlighted = hit.object; origMat = hit.object.material;
        const glow = origMat.clone(); glow.emissive = new THREE.Color(0xff9055); glow.emissiveIntensity = 1.2; highlighted.material = glow;
        const tags = highlighted.userData.tags || {}; const h = Math.round(highlighted.userData.height);
        showTip(e.clientX, e.clientY, `${tags.name? tags.name + ' / ' : ''}高さ: ${h}m`);
      } else { hideTip(); }
    });

    function showTip(x,y, text){ const t = document.getElementById('tooltip'); t.textContent = text; t.style.left=x+'px'; t.style.top=y+'px'; t.style.opacity=1; }
    function hideTip(){ document.getElementById('tooltip').style.opacity = 0; }

    // Status
    const hud = document.getElementById('hud');
    function setStatus(msg){ hud.textContent = msg + ' ｜ データ: OpenStreetMap/Overpass API'; }

    // Resize
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);
    });

    // Animate
    (function loop(){ requestAnimationFrame(loop); controls.update(); renderer.render(scene, camera); })();

    // Boot
    loadAndBuild();
  </script>
</body>
</html>
