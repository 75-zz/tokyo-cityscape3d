<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Tokyo 3D — Pastel City Hunt (OSM + Three.js)</title>
  <style>
    :root{
      --bg:#f6f7fb; --ink:#0b0f14; --glass:rgba(255,255,255,.7); --line:rgba(0,0,0,.08);
      --btn:#ffffff; --btn-line:#d7dce6; --accent:#6aa9ff; --accent2:#ff9ecb; --accent3:#88e1a1;
    }
    html, body { margin: 0; height: 100%; overflow: hidden; background: var(--bg); color: var(--ink); }
    #app { position: fixed; inset: 0; }
    #hud { position: fixed; left: 12px; bottom: 12px; color: var(--ink); font: 12px/1.4 system-ui, "Noto Sans JP", sans-serif; background: var(--glass); border: 1px solid var(--line); padding: 8px 10px; border-radius: 10px; user-select: none; backdrop-filter: blur(8px); z-index:5; }
    #ui { position: fixed; right: 12px; top: 12px; display: flex; gap: 8px; flex-wrap: wrap; z-index: 6; }
    #ui button { background:var(--btn); color:var(--ink); border:1px solid var(--btn-line); padding:8px 12px; border-radius:10px; cursor:pointer; font:12px/1.2 system-ui; box-shadow: 0 1px 0 rgba(0,0,0,.03); }
    #ui button:hover{ filter: brightness(0.98); }
    #tooltip { position: fixed; pointer-events:none; color:var(--ink); background:var(--glass); padding:6px 8px; border-radius:8px; font:12px/1.3 system-ui; transform: translate(-50%,-130%); opacity:0; transition:opacity .12s; border:1px solid var(--line); backdrop-filter: blur(8px); z-index:6; }
    #warn { position: fixed; inset: 12px 12px auto 12px; background: var(--glass); color: var(--ink); border: 1px solid var(--line); padding: 10px 12px; border-radius: 12px; font: 12px/1.5 system-ui, "Noto Sans JP", sans-serif; z-index: 7; display:none; backdrop-filter: blur(8px); }
    #warn strong { color:#4c8dff; }

    /* Overlays */
    .overlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:10; }
    .sheet{ width:min(620px, 94vw); background:var(--glass); border:1px solid var(--line); border-radius:16px; padding:16px; backdrop-filter: blur(10px); box-shadow: 0 20px 60px rgba(0,0,0,.08); }
    .row{ display:flex; gap:12px; align-items:center; }
    .space{ height:12px; }
    .title{ font: 600 16px/1.2 system-ui, "Noto Sans JP"; }
    .muted{ color:#4b5563; font-size:12px; }
    .btn{ background:var(--btn); border:1px solid var(--btn-line); border-radius:10px; padding:8px 12px; cursor:pointer; }
    .btn.primary{ background:linear-gradient(135deg,var(--accent),var(--accent2)); color:white; border:none; }
    .btn.flat{ background:transparent; border: none; color:#1f2937; text-decoration: underline; }
    .grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(160px,1fr)); gap:12px; }
    .card{ background:var(--btn); border:1px solid var(--btn-line); border-radius:12px; padding:10px; text-align:center; display:flex; flex-direction:column; align-items:center; gap:6px; }
    .card .c3d{ width: 140px; height: 110px; border-radius: 10px; overflow: hidden; border:1px solid var(--btn-line); background: #fff; }

    /* Mobile D-Pad */
    #pad { position: fixed; z-index: 6; display: none; /* デスクトップでは非表示 */ }
    .padbtn { background: var(--glass); border:1px solid var(--btn-line); border-radius: 12px; touch-action: none; user-select: none; display:flex; align-items:center; justify-content:center; font: 600 14px/1 system-ui; }
    .padbtn:active{ filter: brightness(.96); }
    .padbtn.empty{ visibility: hidden; }

    /* スマホ系だけ表示＆安全領域にフィット */
    @media (hover: none) and (pointer: coarse) {
      #pad { 
        right: calc(12px + env(safe-area-inset-right));
        bottom: calc(12px + env(safe-area-inset-bottom));
        left: auto;
        width: 160px; height: 160px;
        display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; opacity: .96;
      }
      .padbtn { height: 48px; font-size: 16px; }
    }

    /* 横向きのときは少しコンパクトに */
    @media (hover: none) and (pointer: coarse) and (orientation: landscape) {
      #pad { width: 140px; height: 140px; gap: 8px; }
      .padbtn { height: 42px; font-size: 15px; }
    }


    /* 3D avatars in overlays */
    .c3d-battle, .c3d-result { width: 180px; height: 140px; border-radius: 12px; border:1px solid var(--btn-line); background:#fff; overflow:hidden; }

    /* Loader */
    #loader{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:20; background: radial-gradient(1200px 800px at 50% 40%, rgba(255,255,255,.9), rgba(246,247,251,.95)); }
    #loader .box{ width:min(420px,88vw); background: var(--glass); border:1px solid var(--line); border-radius: 16px; padding: 16px; backdrop-filter: blur(10px); box-shadow: 0 20px 60px rgba(0,0,0,.08); display:flex; flex-direction:column; align-items:center; gap:12px; }
    #loader3d{ width: 200px; height: 160px; border-radius: 12px; border:1px solid var(--btn-line); background:#fff; overflow:hidden; }
    .loadtext{ font: 600 14px/1.2 system-ui, "Noto Sans JP"; }
    .bar{ width: 100%; height: 10px; border-radius: 8px; border:1px solid var(--btn-line); background: #fff; overflow:hidden; }
    .bar > i{ display:block; height:100%; width:0%; background: linear-gradient(90deg, var(--accent), var(--accent2)); }
    .pct{ font: 12px/1.2 system-ui; color:#4b5563; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="app"></div>
  <div id="ui">
    <button data-spot="tokyo">東京駅</button>
    <button data-spot="shinjuku">新宿</button>
    <button data-spot="shibuya">渋谷</button>
    <button data-spot="odaiba">お台場</button>
    <button id="refresh">再取得</button>
    <button id="spawn">新規スポーン</button>
    <button id="dex">図鑑</button>
  </div>
  <div id="hud">Pastel City Hunt｜データ: OpenStreetMap / Overpass API</div>
  <div id="tooltip"></div>
  <div id="warn"></div>

  <!-- Loader Overlay -->
  <div id="loader" class="overlay" style="display:flex">
    <div class="box">
      <div id="loader3d"></div>
      <div class="loadtext">ロード中…</div>
      <div class="bar"><i id="loadBarInner"></i></div>
      <div class="pct" id="loadPct">0%</div>
      <div class="pct" id="loadNote" style="margin-top:6px"></div>
      <button class="btn" id="fallbackBtn" style="margin-top:8px">デモで開始（オフライン用）</button>
    </div>
  </div>

  <!-- Mobile D-Pad -->
  <div id="pad">
    <div class="padbtn empty"></div>
    <div class="padbtn" data-dir="f">▲</div>
    <div class="padbtn empty"></div>
    <div class="padbtn" data-dir="l">◀</div>
    <div class="padbtn" data-dir="b">▼</div>
    <div class="padbtn" data-dir="r">▶</div>
    <div class="padbtn empty"></div>
    <div class="padbtn" data-dir="s">⟲</div>
    <div class="padbtn empty"></div>
  </div>

  <!-- Battle Overlay -->
  <div id="battle" class="overlay">
    <div class="sheet">
      <div class="row"><div class="title">バトル開始！</div><div style="flex:1"></div><button class="btn flat" id="closeBattle">閉じる</button></div>
      <div class="space"></div>
      <div class="row">
        <div class="c3d-battle" id="enemyAvatar"></div>
        <div style="flex:1">
          <div><strong id="enemyName">???</strong></div>
          <div class="muted">HP: <span id="enemyHP">--</span></div>
          <div class="space"></div>
          <div class="row">
            <button class="btn primary" id="attackBtn">こうげき</button>
            <button class="btn" id="runBtn">にげる</button>
          </div>
        </div>
      </div>
      <div class="space"></div>
      <div class="muted" id="battleLog">…</div>
    </div>
  </div>

  <!-- Result Overlay -->
  <div id="result" class="overlay">
    <div class="sheet" style="text-align:center">
      <div class="title">GET!!</div>
      <div class="space"></div>
      <div class="c3d-result" id="resultAvatar"></div>
      <div class="space"></div>
      <div><strong id="resultName">---</strong></div>
      <div class="space"></div>
      <button class="btn primary" id="keepBtn">図鑑に登録</button>
      <button class="btn" id="continueBtn">つづける</button>
    </div>
  </div>

  <!-- Dex Overlay -->
  <div id="dexOverlay" class="overlay">
    <div class="sheet">
      <div class="row"><div class="title">図鑑</div><div style="flex:1"></div><button class="btn flat" id="closeDex">閉じる</button></div>
      <div class="space"></div>
      <div id="dexGrid" class="grid"></div>
    </div>
  </div>

  <script>
    // 注意喚起
    (function(){
      const warn = document.getElementById('warn');
      const importMapSupported = ('supports' in HTMLScriptElement && HTMLScriptElement.supports('importmap'));
      let msgs = [];
      if (location.protocol === 'file:') {
        msgs.push('現在 <strong>file://</strong> で開いています。環境によっては動作しないことがあります。<br>うまくいかない場合は、<code>python -m http.server</code> 等で http://localhost:8000 から開いてください。');
      }
      if (!importMapSupported) msgs.push('このブラウザは <strong>importmap</strong> に対応していない可能性があります。最新ブラウザを推奨。');
      msgs.push('このアプリは <strong>インターネット接続</strong> と <strong>Overpass API</strong> が必要です。');
      if (msgs.length) { warn.innerHTML = msgs.join('<hr style="border:none;border-top:1px solid var(--line);margin:8px 0">'); warn.style.display='block'; setTimeout(()=>warn.style.display='none', 8000); }
    })();
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // ---- Config ----
    const RADIUS_M = 800; // OSMの取得半径
    const CENTER_PRESETS = {
      tokyo:   [139.767125, 35.681236], // 東京駅
      shinjuku:[139.700556, 35.689722],
      shibuya: [139.702148, 35.659516],
      odaiba:  [139.775,    35.625]
    };
    let center = CENTER_PRESETS.tokyo.slice();

    // モンスター定義（IP回避のオリジナル）
    const MONS = [
      { key:'fluffin', name:'フラッフィン', color:'#ffd1e6', power:[8,14] },
      { key:'sparkid', name:'スパーキッド', color:'#cfe6ff', power:[10,16] },
      { key:'mossie',  name:'モッシー',     color:'#dff6df', power:[7,12] },
      { key:'embero',  name:'エンベロ',     color:'#ffe3c3', power:[9,15] },
      { key:'glacio',  name:'グラシオ',     color:'#e6f3ff', power:[11,17] }
    ];

    // ---- Three.js setup ----
    const container = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#f6f7fb');

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 8000);
    camera.position.set(0, 540, 1100);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.minDistance = 50;
    controls.maxDistance = 4000;

    // ライト
    const amb = new THREE.AmbientLight(0xffffff, 0.9); scene.add(amb);
    const sun = new THREE.DirectionalLight(0xffffff, 0.8); sun.position.set(800, 1500, 600); scene.add(sun);

    // 地面
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(4000, 4000), new THREE.MeshStandardMaterial({ color: 0xf0f4ff, roughness: 1 }));
    ground.rotation.x = -Math.PI / 2; ground.position.y = 0; scene.add(ground);

    // グリッド
    let grid = new THREE.GridHelper(4000, 80, 0xbed2ff, 0xdee7ff); grid.position.y = 0.02; scene.add(grid);

    const city = new THREE.Group(); scene.add(city);
    const spawns = new THREE.Group(); scene.add(spawns);

    // Raycast
    const tooltip = document.getElementById('tooltip');
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // ---- Utils: WebMercator ----
    const DEG2RAD = Math.PI / 180; const R = 6378137;
    function lonLatToMeters(lon, lat){ const x = R * lon * DEG2RAD; const y = R * Math.log(Math.tan(Math.PI/4 + (lat*DEG2RAD)/2)); return [x, y]; }
    function localXY(lon, lat, originLon, originLat){ const [ox, oy] = lonLatToMeters(originLon, originLat); const [x, y] = lonLatToMeters(lon, lat); return [x - ox, -(y - oy)]; }

    // ---- Overpass fetch ----
    const OVERPASS_MIRRORS = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter',
      'https://z.overpass-api.de/api/interpreter'
    ];
    async function fetchWithTimeout(url, options={}, timeoutMs=12000){
      const ac = new AbortController(); const id = setTimeout(()=>ac.abort(new Error('timeout')), timeoutMs);
      try{ const res = await fetch(url, { ...options, signal: ac.signal }); return res; } finally { clearTimeout(id); }
    }
    async function fetchBuildings(lon, lat, radiusMeters){
      const dLat = (radiusMeters / 111320);
      const dLon = radiusMeters / (111320 * Math.cos(lat * DEG2RAD));
      const s = lat - dLat, w = lon - dLon, n = lat + dLat, e = lon + dLon;
      const query = `
[out:json][timeout:25];
(
  way["building"](${s},${w},${n},${e});
  relation["building"](${s},${w},${n},${e});
);
out body;
>;
out skel qt;`;
      let lastErr = null;
      for(let i=0;i<OVERPASS_MIRRORS.length;i++){
        const url = OVERPASS_MIRRORS[i];
        setLoaderNote(`Overpassに接続中…（${i+1}/${OVERPASS_MIRRORS.length}）`);
        try{
          const res = await fetchWithTimeout(url, { method:'POST', body: query, headers: { 'Content-Type': 'text/plain' } }, 12000);
          if(!res.ok) throw new Error('HTTP '+res.status);
          return await res.json();
        }catch(err){ lastErr = err; console.warn('Overpass try failed', url, err); }
      }
      throw new Error('Overpass APIに接続できませんでした: ' + (lastErr?.message||'unknown'));
    }

    // ---- Build meshes from OSM ----
    function buildCityFromOSM(osm, onProgress){
      city.clear(); spawns.clear();
      const nodes = new Map();
      for(const el of osm.elements){ if(el.type === 'node') nodes.set(el.id, el); }
      const palette = ['#cfe0ff','#d8f0ff','#ffe7f3','#e7ffef','#fff5cc'];

      function heightFromTags(tags){
        if(!tags) return 16 + Math.random()*48;
        if(tags?.height){ const m = String(tags.height).match(/([0-9.]+)/); if(m) return parseFloat(m[1]); }
        if(tags?.["building:levels"]) return parseFloat(tags["building:levels"]) * 3 + 3;
        return 12 + Math.random()*40;
      }

      let total=0; for(const el of osm.elements){ if(el.type==='way' && el.tags?.building) total++; }
      let built=0;
      for(const el of osm.elements){
        if(el.type !== 'way' || !el.tags?.building) continue;
        const pts = [];
        for(const nid of el.nodes){ const nd = nodes.get(nid); if(!nd) { pts.length=0; break; } pts.push(localXY(nd.lon, nd.lat, center[0], center[1])); }
        if(pts.length < 3) continue;
        const first = pts[0], last = pts[pts.length-1];
        if(first[0] !== last[0] || first[1] !== last[1]) pts.push(first);
        const shape = new THREE.Shape(); shape.moveTo(pts[0][0], pts[0][1]); for(let i=1;i<pts.length;i++) shape.lineTo(pts[i][0], pts[i][1]);
        const h = heightFromTags(el.tags);
        const geom = new THREE.ExtrudeGeometry(shape, { depth: h, bevelEnabled: false });
        geom.rotateX(-Math.PI/2); geom.computeVertexNormals();
        const baseColor = new THREE.Color(palette[(Math.random()*palette.length)|0]);
        const mat = new THREE.MeshStandardMaterial({ color: baseColor.clone(), metalness: 0.05, roughness: 0.9, emissive: 0xffffff, emissiveIntensity: 0.05 });
        const mesh = new THREE.Mesh(geom, mat); mesh.userData.baseColor = baseColor.clone(); mesh.position.y = 0; mesh.castShadow = false; mesh.receiveShadow = false; mesh.userData = { tags: el.tags, height: h };
        city.add(mesh);
        built++; if(onProgress){ const p = 75 + Math.floor(25 * built / Math.max(1,total)); onProgress(p); }
      }

      spawnMonsters();
      applyTimeOfDayTheme(true);
    }

    // ---- Monster models (more details) ----
    function makeMonsterModel(mon, opts={}){ const { withRing=true } = opts; 
      const g = new THREE.Group();
      g.userData.mon = mon;
      const toon = (c)=> new THREE.MeshToonMaterial({ color: new THREE.Color(c) });
      const mainMat = toon(mon.color);
      const white = toon('#ffffff');
      const dark = toon('#1f2937');

      const addEye = (x,y,z,s=1)=>{
        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.9*s, 16, 16), dark);
        eye.position.set(x,y,z); g.add(eye);
      };

      const addBlush = (x,y,z)=>{
        const b = new THREE.Mesh(new THREE.SphereGeometry(0.8, 12, 12), toon('#ffb5d1'));
        b.position.set(x,y,z); b.scale.set(1.4,0.6,1.2); g.add(b);
      };

      switch(mon.key){
        case 'fluffin': {
          const body = new THREE.Mesh(new THREE.SphereGeometry(8, 24, 24), mainMat);
          const earL = new THREE.Mesh(new THREE.ConeGeometry(3.2, 5.5, 12), mainMat);
          const earR = earL.clone(); earL.material.side = earR.material.side = THREE.DoubleSide;
          earL.position.set(-4, 10, 0); earL.rotation.z = 0.2; earR.position.set(4, 10, 0); earR.rotation.z = -0.2;
          const footL = new THREE.Mesh(new THREE.SphereGeometry(2.2, 16, 16), mainMat); const footR = footL.clone();
          footL.position.set(-3, -7.5, 2); footR.position.set(3, -7.5, 2);
          addEye(-2.2, 3.2, 7.4); addEye(2.2, 3.2, 7.4); addBlush(-3.5, 1.8, 6.6); addBlush(3.5, 1.8, 6.6);
          g.add(body, earL, earR, footL, footR);
          g.userData.anim = 'float';
          break;
        }
        case 'sparkid': {
          const body = new THREE.Mesh(new THREE.BoxGeometry(12, 9, 10), mainMat);
          const ant = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 7, 12), white);
          const tip = new THREE.Mesh(new THREE.SphereGeometry(1.6, 16, 16), white);
          const armL = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 5, 10), mainMat);
          const armR = armL.clone(); armL.position.set(-7, 0.5, 0); armR.position.set(7, 0.5, 0); armL.rotation.z = 1.2; armR.rotation.z = -1.2;
          ant.position.set(0, 7.5, 0); tip.position.set(0, 11.5, 0);
          addEye(-2.8, 2.5, 5.2); addEye(2.8, 2.5, 5.2);
          g.add(body, ant, tip, armL, armR);
          g.userData.parts = { ant, tip };
          g.userData.anim = 'antenna';
          break;
        }
        case 'mossie': {
          const body = new THREE.Mesh(new THREE.SphereGeometry(7.5, 24, 24), mainMat);
          const tail = new THREE.Mesh(new THREE.ConeGeometry(3.2, 6.5, 12), mainMat); tail.material.side = THREE.DoubleSide; tail.rotation.x = Math.PI; tail.position.set(0, -7, -1);
          const wingL = new THREE.Mesh(new THREE.ConeGeometry(2.2, 8, 12), white); const wingR = wingL.clone();
          wingL.material.side = wingR.material.side = THREE.DoubleSide; wingL.rotation.z =  1.1; wingL.position.set(-7, 2, 0); wingR.rotation.z = -1.1; wingR.position.set(7, 2, 0);
          const leaf = new THREE.Mesh(new THREE.CapsuleGeometry(1.5, 3.5, 6, 10), toon('#a0e6b6')); leaf.rotation.z = 0.5; leaf.position.set(-1.2, 8.5, -1);
          addEye(-2.1, 2.6, 6.7); addEye(2.1, 2.6, 6.7);
          g.add(body, tail, wingL, wingR, leaf);
          g.userData.parts = { wingL, wingR };
          g.userData.anim = 'flap';
          break;
        }
        case 'embero': {
          const body = new THREE.Mesh(new THREE.SphereGeometry(7.5, 24, 24), mainMat);
          const f1 = new THREE.Mesh(new THREE.ConeGeometry(2.2, 7, 8), toon('#ffdcb3'));
          const f2 = f1.clone(); const f3 = f1.clone(); f1.material.side = f2.material.side = f3.material.side = THREE.DoubleSide;
          f1.position.set(0, 9.5, 0); f2.position.set(-2.6, 8.8, -1.2); f2.rotation.z = 0.4; f3.position.set(2.6, 8.8, -1.2); f3.rotation.z = -0.4;
          const tail = new THREE.Mesh(new THREE.ConeGeometry(1.8, 5.5, 8), toon('#ffb899')); tail.rotation.x = Math.PI; tail.position.set(0, -7, -1.5);
          addEye(-2.2, 2.4, 6.7); addEye(2.2, 2.4, 6.7);
          g.add(body, f1, f2, f3, tail);
          g.userData.parts = { f1, f2, f3 };
          g.userData.anim = 'flicker';
          break;
        }
        case 'glacio': {
          const body = new THREE.Mesh(new THREE.IcosahedronGeometry(7.5, 0), mainMat);
          const shard1 = new THREE.Mesh(new THREE.ConeGeometry(2, 6, 6), toon('#e7f2ff'));
          const shard2 = shard1.clone(); shard1.material.side = shard2.material.side = THREE.DoubleSide;
          shard1.position.set(-4, -5, -2); shard1.rotation.x = -0.6; shard2.position.set(4, -5, -2); shard2.rotation.x = -0.6;
          addEye(-2.0, 1.8, 6.8); addEye(2.0, 1.8, 6.8);
          g.add(body, shard1, shard2);
          g.userData.parts = { body };
          g.userData.anim = 'spin';
          break;
        }
      }

      // 口（全員共通、前面に小さなリング）
      const mouth = new THREE.Mesh(new THREE.TorusGeometry(1.2, 0.35, 8, 24), dark); mouth.rotation.x = Math.PI/2; mouth.position.set(0, 0.2, 7.2); g.add(mouth);

      // 足場リング（フィールド表示のみ）
      if(withRing){ const ring = new THREE.Mesh(new THREE.TorusGeometry(14, 1.5, 8, 32), new THREE.MeshStandardMaterial({ color: '#ffffff', emissive: 0xffffff, emissiveIntensity: 0.2 })); ring.rotation.x = Math.PI/2; g.add(ring); }

      // エッジ線で視認性UP
      const outlines = [];
      g.traverse(obj=>{ if(obj.isMesh){ const eg = new THREE.EdgesGeometry(obj.geometry, 20); outlines.push(new THREE.LineSegments(eg, new THREE.LineBasicMaterial({ color: 0x2f3947, transparent:true, opacity:0.32 }))); } });
      outlines.forEach(ls=>g.add(ls));

      g.scale.set(2.4, 2.4, 2.4);
      return g;
    }

    // ---- Spawns ----
    function spawnMonsters(count = 10){
      spawns.clear();
      const area = 900;
      for(let i=0;i<count;i++){
        const mon = MONS[(Math.random()*MONS.length)|0];
        const g = makeMonsterModel(mon, { withRing:true });
        const x = (Math.random()-0.5)*2*area; const z = (Math.random()-0.5)*2*area; const y = getTopHeightAt(x, z) + 6;
        g.position.set(x, y, z); g.rotation.y = Math.random()*Math.PI*2; g.userData.type = 'spawn';
        // ランダム徘徊AI 初期化
        g.userData.wander = { state: Math.random()<0.5 ? 'move':'stop', t: 0.5 + Math.random()*1.5, speed: 20 + Math.random()*25, dir: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize(), area };
        spawns.add(g);
      }
    }

    function getTopHeightAt(x, z){
      const rc = new THREE.Raycaster(new THREE.Vector3(x, 5000, z), new THREE.Vector3(0, -1, 0));
      const hits = rc.intersectObjects(city.children, false); return hits.length ? hits[0].point.y : 0;
    }

    // ---- Battle state ----
    const battleEl = document.getElementById('battle');
    const enemyNameEl = document.getElementById('enemyName');
    const enemyHPEl = document.getElementById('enemyHP');
    const battleLogEl = document.getElementById('battleLog');
    const attackBtn = document.getElementById('attackBtn');
    const runBtn = document.getElementById('runBtn');
    const closeBattle = document.getElementById('closeBattle');

    let currentEnemy = null; let enemyHP = 0; let myHP = 30;

    function openBattle(mon){
      currentEnemy = mon; enemyHP = 20 + Math.floor(Math.random()*15); myHP = 30;
      enemyNameEl.textContent = mon.name; enemyHPEl.textContent = enemyHP;
      battleEl.style.display = 'flex'; // 先に表示してからサイズ計測
      ensureCard(enemyAvatar, mon);
      battleLogEl.textContent = '野生の ' + mon.name + ' があらわれた！';
    }

    function closeBattleUI(){ battleEl.style.display = 'none'; }

    attackBtn?.addEventListener('click', ()=>{
      if(!currentEnemy) return;
      const dmg = randInt(...currentEnemy.power);
      enemyHP = Math.max(0, enemyHP - dmg);
      enemyHPEl.textContent = enemyHP;
      battleLogEl.textContent = `${currentEnemy.name} に ${dmg} ダメージ！`;
      if(enemyHP === 0){ playFanfare(); setTimeout(()=> openResult(currentEnemy), 400); battleEl.style.display = 'none'; return; }
      const counter = randInt(3,8); myHP = Math.max(0, myHP - counter);
      battleLogEl.textContent += ` / こうげきをうけた！ (${counter})`;
    });

    runBtn?.addEventListener('click', ()=>{ battleLogEl.textContent = 'にげた！'; setTimeout(closeBattleUI, 250); });
    closeBattle?.addEventListener('click', closeBattleUI);

    // ---- Result ----
    const resultEl = document.getElementById('result');
    const resultName = document.getElementById('resultName');
    const keepBtn = document.getElementById('keepBtn');
    const continueBtn = document.getElementById('continueBtn');
    let captured = null;

    function openResult(mon){
      captured = mon; resultName.textContent = mon.name;
      resultEl.style.display='flex'; // 先に表示
      ensureCard(resultAvatar, mon);
    }
    keepBtn?.addEventListener('click', ()=>{ if(captured){ addToDex(captured); } resultEl.style.display='none'; });
    continueBtn?.addEventListener('click', ()=>{ resultEl.style.display='none'; });

    // ---- Dex (localStorage) ----
    const DEX_KEY = 'pastel_city_dex_v2';
    const dexOverlay = document.getElementById('dexOverlay');
    const dexGrid = document.getElementById('dexGrid');
    const closeDexBtn = document.getElementById('closeDex');
    function loadDex(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY) || '[]'); }catch{ return []; } }
    function saveDex(list){ localStorage.setItem(DEX_KEY, JSON.stringify(list)); }
    function addToDex(mon){ const list = loadDex(); list.push({ key: mon.key, name: mon.name, color: mon.color, ts: Date.now() }); saveDex(list); showDex(); }
    function showDex(){
      const list = loadDex(); dexGrid.innerHTML = '';
      dexOverlay.style.display='flex'; // 先に表示
      if(list.length===0){ dexGrid.innerHTML = '<div class="muted">まだ何も捕まえていません。</div>'; }
      else{
        for(const it of list){
          const d = document.createElement('div'); d.className='card';
          const c = document.createElement('div'); c.className='c3d'; d.appendChild(c);
          const name = document.createElement('div'); name.innerHTML = `<strong>${it.name}</strong>`; d.appendChild(name);
          const time = document.createElement('div'); time.className='muted'; time.textContent = new Date(it.ts).toLocaleString(); d.appendChild(time);
          dexGrid.appendChild(d);
          ensureCard(c, it, true);
          // 図鑑カード：クリックで一回転＆鳴き声
          c.style.cursor = 'pointer';
          c.addEventListener('click', ()=>{ const entry = containerToCard.get(c); if(entry){ entry.spin = Math.PI*2; } playCry(it); });
        }
      }
    }
    closeDexBtn?.addEventListener('click', ()=> dexOverlay.style.display='none');
    document.getElementById('dex').addEventListener('click', showDex);

    // ---- Card renderer (3D monster in UI boxes) ----
    const cardScenes = new Set();
    const containerToCard = new Map();
    function ensureCard(container, mon, small=false){
      container.innerHTML = '';
      const scene = new THREE.Scene(); scene.background = new THREE.Color('#ffffff');
      const cam = new THREE.PerspectiveCamera(38, 1, 0.01, 2000);
      const light = new THREE.HemisphereLight(0xffffff, 0xdde5ff, 1); scene.add(light);
      const dlight = new THREE.DirectionalLight(0xffffff, .8); dlight.position.set(1,2,1); scene.add(dlight);
      const model = makeMonsterModel(mon, { withRing:false });
      scene.add(model);

      const r = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'low-power' });
      const getSize = ()=>{
        const cs = getComputedStyle(container);
        const w = Math.max(1, container.clientWidth || parseFloat(cs.width) || (small?140:180));
        const h = Math.max(1, container.clientHeight || parseFloat(cs.height) || (small?110:140));
        return [w|0, h|0];
      };
      let [w,h] = getSize();
      r.setPixelRatio( Math.min(devicePixelRatio, 1.5) );
      r.setSize(w, h);
      container.appendChild(r.domElement);

      // フィット
      const box = new THREE.Box3().setFromObject(model);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);
      model.position.sub(center);
      cam.aspect = w / h; cam.updateProjectionMatrix();
      const vFov = THREE.MathUtils.degToRad(cam.fov);
      const fitH = (size.y/2) / Math.tan(vFov/2);
      const fitW = (size.x/2) / (Math.tan(vFov/2) * cam.aspect);
      const dist = Math.max(fitH, fitW) * 1.35 + size.z*0.2;
      cam.position.set(0, 0, dist);
      cam.near = Math.max(0.01, dist/50); cam.far = dist*50; cam.updateProjectionMatrix();
      cam.lookAt(0, 0, 0);

      const entry = { r, scene, cam, model, mon };
      cardScenes.add(entry);
      containerToCard.set(container, entry);

      // クリックで鳴き声
      r.domElement.addEventListener('pointerdown', ()=> playCry(mon));

      // Resize observer
      const ro = new ResizeObserver(()=>{
        [w,h] = getSize(); r.setSize(w,h); cam.aspect = w/h; cam.updateProjectionMatrix();
        const vFov = THREE.MathUtils.degToRad(cam.fov);
        const fitH = (size.y/2) / Math.tan(vFov/2);
        const fitW = (size.x/2) / (Math.tan(vFov/2) * cam.aspect);
        const dist = Math.max(fitH, fitW) * 1.35 + size.z*0.2;
        cam.position.set(0, 0, dist); cam.near=Math.max(0.01, dist/50); cam.far=dist*50; cam.updateProjectionMatrix();
        r.render(scene, cam);
      });
      ro.observe(container);

      // 初回だけ描画
      r.render(scene, cam);
    }

    // ---- Movement: keyboard & on-screen D-Pad ----
    const move = { f:false, b:false, l:false, r:false, s:false };
    const setMove = (k,val)=>{ if(k in move) move[k]=val; };
    const keyMap = { 'KeyW':'f','ArrowUp':'f','KeyS':'b','ArrowDown':'b','KeyA':'l','ArrowLeft':'l','KeyD':'r','ArrowRight':'r','ShiftLeft':'s','ShiftRight':'s' };
    addEventListener('keydown', (e)=>{ const k = keyMap[e.code]; if(k){ setMove(k,true); } });
    addEventListener('keyup', (e)=>{ const k = keyMap[e.code]; if(k){ setMove(k,false); } });

    // Touch buttons
    document.getElementById('pad').addEventListener('pointerdown', (e)=>{ const b = e.target.closest('.padbtn'); if(!b) return; const d=b.dataset.dir; if(!d) return; setMove(d,true); b.setPointerCapture(e.pointerId); });
    document.getElementById('pad').addEventListener('pointerup', (e)=>{ const b = e.target.closest('.padbtn'); if(!b) return; const d=b.dataset.dir; if(!d) return; setMove(d,false); });
    document.getElementById('pad').addEventListener('pointercancel', (e)=>{ for(const k in move) move[k]=false; });
    document.getElementById('pad').addEventListener('pointerleave', (e)=>{ for(const k in move) move[k]=false; });

    // ---- Load & build ----
    async function loadAndBuild(){
      setStatus('OSM建物取得中…');
      showLoader(); setLoaderProgress(10);
      setLoaderNote(navigator.onLine ? '' : 'オフラインの可能性があります…デモで開始も可');
      let sim = 10; const simTimer = setInterval(()=>{ sim = Math.min(sim+1, 70); setLoaderProgress(sim); }, 90);
      try{
        const data = await fetchBuildings(center[0], center[1], RADIUS_M);
        clearInterval(simTimer); setLoaderProgress(75);
        buildCityFromOSM(data, (p)=> setLoaderProgress(p));
        fitCamera(); setStatus('完了: ' + city.children.length + ' 棟 / スポーン: ' + spawns.children.length);
        setLoaderProgress(100);
        setTimeout(hideLoader, 250);
      }
      catch(err){
        console.error(err);
        clearInterval(simTimer);
        setStatus('取得失敗: ' + err.message);
        setLoaderNote('混雑/ネット不安定の可能性。下の「デモで開始」を使えます。');
        setLoaderProgress(100, 'エラー');
        return; // ローダーを出したまま
      }
      // テーマ反映
      applyTimeOfDayTheme(true);
    }

    function fitCamera(){ controls.target.set(0,0,0); camera.position.set(0, 540, 1100); controls.update(); }

    document.getElementById('ui').addEventListener('click', (e)=>{
      const btn = e.target.closest('button'); if(!btn) return;
      if(btn.id === 'refresh'){ loadAndBuild(); return; }
      if(btn.id === 'spawn'){ spawnMonsters(10); setStatus('スポーン作成: ' + spawns.children.length); return; }
      if(btn.dataset.spot){ const key = btn.dataset.spot; if(CENTER_PRESETS[key]){ center = CENTER_PRESETS[key].slice(); loadAndBuild(); } }
    });

    function findSpawnGroup(obj){ let cur = obj; while(cur && cur.parent){ if(cur.userData && cur.userData.type==='spawn') return cur; cur = cur.parent; } return null; }

    // Click interactions
    addEventListener('pointerdown', (e)=>{
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left)/rect.width)*2 - 1; mouse.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hitsSpawn = raycaster.intersectObjects(spawns.children, true);
      if(hitsSpawn.length){ const root = findSpawnGroup(hitsSpawn[0].object); if(root){ playCry(root.userData.mon); openBattle(root.userData.mon); } return; }
      const hitB = raycaster.intersectObjects(city.children, false)[0];
      if(hitB){ const tags = hitB.object.userData.tags || {}; const h = Math.round(hitB.object.userData.height); showTip(e.clientX, e.clientY, `${tags.name? tags.name + ' / ' : ''}高さ: ${h}m`); } else { hideTip(); }
    });

    function showTip(x,y, text){ const t = document.getElementById('tooltip'); t.textContent = text; t.style.left=x+'px'; t.style.top=y+'px'; t.style.opacity=1; }
    function hideTip(){ document.getElementById('tooltip').style.opacity = 0; }

    // Status
    const hud = document.getElementById('hud');
    function setStatus(msg){ hud.textContent = `Pastel City Hunt｜${msg}`; }

    // Resize
    addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    // Animate (main + card scenes)
    const clock = new THREE.Clock();
    ;(function loop(){
      requestAnimationFrame(loop);
      const dt = Math.min(clock.getDelta(), 0.033);

      // Camera move
      const spd = (move.s ? 140 : 70) * dt;
      const f = new THREE.Vector3(); camera.getWorldDirection(f); f.y = 0; f.normalize();
      const r = new THREE.Vector3().crossVectors(f, new THREE.Vector3(0,1,0)).normalize();
      const mv = new THREE.Vector3();
      if(move.f) mv.add(f); if(move.b) mv.addScaledVector(f, -1); if(move.r) mv.add(r); if(move.l) mv.addScaledVector(r, -1);
      if(mv.lengthSq()>0){ mv.normalize().multiplyScalar(spd); camera.position.add(mv); controls.target.add(mv); }

      // Spawn anims
      const t = performance.now()/1000;
      spawns.children.forEach((g,i)=>{
        const w = g.userData.wander; if(w){
          w.t -= dt;
          if(w.t <= 0){
            if(w.state === 'move'){ w.state = 'stop'; w.t = 0.5 + Math.random()*1.5; }
            else { w.state = 'move'; w.t = 1.2 + Math.random()*2.0; w.dir.set(Math.random()-0.5,0,Math.random()-0.5).normalize(); w.speed = 20 + Math.random()*25; }
          }
          if(w.state === 'move'){
            const step = w.speed * dt; g.position.x += w.dir.x * step; g.position.z += w.dir.z * step;
            if(Math.abs(g.position.x) > w.area || Math.abs(g.position.z) > w.area){ w.dir.multiplyScalar(-1); }
            g.position.y = 12 + Math.sin(t*1.6 + i)*1.5; const top = getTopHeightAt(g.position.x, g.position.z) + 6; if(g.position.y < top) g.position.y = top;
            g.rotation.y = Math.atan2(w.dir.x, w.dir.z);
          }
        }
        const mon = g.userData.mon; const parts = g.userData.parts||{};
        if(mon?.key==='mossie' && parts.wingL && parts.wingR){ const a = Math.sin(t*6 + i)*0.5 + 0.6; parts.wingL.rotation.z =  1.1 + a*0.25; parts.wingR.rotation.z = -1.1 - a*0.25; }
        if(mon?.key==='sparkid' && parts.ant && parts.tip){ parts.ant.rotation.z = Math.sin(t*4 + i)*0.15; parts.tip.position.y = 11.5 + Math.sin(t*3 + i)*0.4; }
        if(mon?.key==='embero' && parts.f1){ const k = Math.sin(t*5 + i)*0.08; parts.f1.rotation.z = k; if(parts.f2) parts.f2.rotation.z = 0.4 + k; if(parts.f3) parts.f3.rotation.z = -0.4 - k; }
        if(mon?.key==='glacio' && parts.body){ parts.body.rotation.y += 0.01; }
      });

      controls.update(); renderer.render(scene, camera);

      // Render small card scenes + spin reactions
      cardScenes.forEach((entry)=>{ if(entry.spin && entry.spin>0){ const step = 0.18; entry.model.rotation.y += step; entry.spin -= step; } entry.r.render(entry.scene, entry.cam); });

      // Loader 3D
      if(loaderState.active){ renderLoader3D(); }
    })();

    // Helpers
    function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

    // ---- Time-of-day THEME (auto: 朝/昼/夕/夜) ----
    let currentPhase = null;
    function phaseFromDate(d){ const h = d.getHours();
      if(h >= 5 && h < 9) return 'dawn';
      if(h >= 9 && h < 17) return 'day';
      if(h >= 17 && h < 19) return 'dusk';
      return 'night';
    }
    const THEMES = {
      dawn: { sky:'#f7f2ff', ground:'#eef4ff', uiBg:'#f6f7fb', uiInk:'#0b0f14', grid1:0xdecfff, grid2:0xeaf2ff,
              ambI:0.9, sunI:0.7, sunC:'#ffd4a8', fogC:'#f0f4ff', fogN:2000, fogF:6000, bBright:1.05, bEmiss:'#ffffff', bEmissI:0.05 },
      day:  { sky:'#f6f7fb', ground:'#f0f4ff', uiBg:'#f6f7fb', uiInk:'#0b0f14', grid1:0xbed2ff, grid2:0xdee7ff,
              ambI:1.0, sunI:0.8, sunC:'#ffffff', fogC:null, fogN:0, fogF:0, bBright:1.0, bEmiss:'#ffffff', bEmissI:0.03 },
      dusk: { sky:'#ffece1', ground:'#fff3e8', uiBg:'#fff5ef', uiInk:'#111827', grid1:0xffc9a9, grid2:0xffeedf,
              ambI:0.7, sunI:0.6, sunC:'#ffb07a', fogC:'#ffe8d8', fogN:1800, fogF:5200, bBright:0.9, bEmiss:'#ffd9b6', bEmissI:0.06 },
      night:{ sky:'#0b1220', ground:'#0f1524', uiBg:'#0f1524', uiInk:'#e5ecff', grid1:0x1f2a44, grid2:0x253252,
              ambI:0.35, sunI:0.25, sunC:'#8fb5ff', fogC:'#0a1020', fogN:1200, fogF:4200, bBright:0.55, bEmiss:'#9fc6ff', bEmissI:0.12 }
    };
    function applyThemeToBuildings(th){ city.children.forEach(m=>{ if(!m.isMesh) return; const mat=m.material; const base=m.userData.baseColor||mat.color.clone(); mat.color.copy(base).multiplyScalar(th.bBright); mat.emissive.set(th.bEmiss); mat.emissiveIntensity = th.bEmissI; }); }
    function rebuildGrid(th){ if(grid){ scene.remove(grid); grid.geometry.dispose(); if(Array.isArray(grid.material)){ grid.material.forEach(m=>m.dispose()); } else { grid.material.dispose?.(); } }
      grid = new THREE.GridHelper(4000, 80, th.grid1, th.grid2); grid.position.y = 0.02; scene.add(grid); }
    function applyTimeOfDayTheme(skipHud=false){ const ph = phaseFromDate(new Date()); if(ph===currentPhase) return; currentPhase = ph; const th = THEMES[ph];
      // UI variables
      document.documentElement.style.setProperty('--bg', th.uiBg);
      document.documentElement.style.setProperty('--ink', th.uiInk);
      // Scene
      scene.background = new THREE.Color(th.sky);
      if(th.fogC){ scene.fog = new THREE.Fog(th.fogC, th.fogN, th.fogF); } else { scene.fog = null; }
      amb.intensity = th.ambI; sun.intensity = th.sunI; sun.color = new THREE.Color(th.sunC);
      ground.material.color = new THREE.Color(th.ground);
      rebuildGrid(th);
      applyThemeToBuildings(th);
      if(!skipHud) setStatus(`時間帯: ${ph === 'dawn' ? '朝' : ph === 'day' ? '昼' : ph === 'dusk' ? '夕' : '夜'}`);
    }
    // 自動更新（毎分）
    setInterval(()=>applyTimeOfDayTheme(), 60*1000);
    addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible') applyTimeOfDayTheme(); });

    // ---- Audio（鳴き声＆勝利ファンファーレ） ----
    let ACTX = null;
    function ensureAudio(){ if(!ACTX){ const C = window.AudioContext || window.webkitAudioContext; if(C){ ACTX = new C(); } } if(ACTX?.state === 'suspended'){ ACTX.resume(); } }
    function beep(freq=600, dur=0.12, type='triangle', vol=0.03, t0){ if(!ACTX) return; const t = t0 ?? ACTX.currentTime; const o=ACTX.createOscillator(); const g=ACTX.createGain(); o.type=type; o.frequency.setValueAtTime(freq, t); g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(vol, t+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t+dur); o.connect(g).connect(ACTX.destination); o.start(t); o.stop(t+dur); }
    function playCry(mon){ ensureAudio(); if(!ACTX) return; switch(mon.key){
      case 'fluffin': beep(680,0.11,'triangle',0.03); beep(920,0.09,'triangle',0.025, ACTX.currentTime+0.09); break;
      case 'sparkid': beep(520,0.08,'square',0.025); beep(1040,0.06,'square',0.02, ACTX.currentTime+0.07); break;
      case 'mossie':  beep(600,0.1,'sine',0.02);  beep(760,0.12,'sine',0.02, ACTX.currentTime+0.11); break;
      case 'embero':  beep(440,0.08,'sawtooth',0.02); beep(660,0.08,'triangle',0.02, ACTX.currentTime+0.08); break;
      case 'glacio':  beep(840,0.09,'sine',0.02);  beep(700,0.07,'sine',0.02, ACTX.currentTime+0.07); break;
    } }
    function playFanfare(){ ensureAudio(); if(!ACTX) return; const t = ACTX.currentTime; // 短いファンファーレ（約0.9s）
      // 上昇アルペジオ + 着地
      beep(784,0.18,'square',0.04,t);   // G5
      beep(988,0.18,'square',0.04,t+0.16); // B5
      beep(1175,0.22,'square',0.05,t+0.32); // D6
      // 和音でキメ
      beep(784,0.35,'triangle',0.03,t+0.54);
      beep(988,0.35,'triangle',0.03,t+0.54);
      beep(1175,0.35,'triangle',0.03,t+0.54);
    }

    // 初回ユーザー操作でAudioContextを起動
    addEventListener('pointerdown', ensureAudio, { once: true });

    // ---- Loader logic ----
    let loaderState = { active:false, r:null, scene:null, cam:null, model:null };
    const loaderEl = document.getElementById('loader');
    const loader3d = document.getElementById('loader3d');
    const loadBarInner = document.getElementById('loadBarInner');
    const loadPct = document.getElementById('loadPct');
    const loadNote = document.getElementById('loadNote');
    const fallbackBtn = document.getElementById('fallbackBtn');

    function showLoader(){
      if(loaderState.active) return;
      loaderEl.style.display = 'flex';
      // 3D setup
      const scene = new THREE.Scene(); scene.background = new THREE.Color('#ffffff');
      const cam = new THREE.PerspectiveCamera(35, loader3d.clientWidth/loader3d.clientHeight, 0.01, 2000);
      cam.position.set(0,0,40);
      const l1 = new THREE.HemisphereLight(0xffffff, 0xdde5ff, 1); scene.add(l1);
      const l2 = new THREE.DirectionalLight(0xffffff, 0.8); l2.position.set(1,2,1); scene.add(l2);
      const mon = MONS[(Math.random()*MONS.length)|0];
      const model = makeMonsterModel(mon, { withRing:false }); scene.add(model);
      const r = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'low-power' });
      r.setPixelRatio(Math.min(devicePixelRatio, 1.5)); r.setSize(loader3d.clientWidth, loader3d.clientHeight); loader3d.innerHTML=''; loader3d.appendChild(r.domElement);
      loaderState = { active:true, r, scene, cam, model };
      setLoaderProgress(10);
      // Fit
      const box = new THREE.Box3().setFromObject(model); const size = new THREE.Vector3(); box.getSize(size); const center = new THREE.Vector3(); box.getCenter(center);
      model.position.sub(center); cam.lookAt(0,0,0);
    }
    function setLoaderProgress(p, label){ const v = Math.max(0, Math.min(100, Math.floor(p))); if(loadBarInner){ loadBarInner.style.width = v+'%'; } if(loadPct){ loadPct.textContent = (label? label+' ' : '') + v + '%'; } }
    function setLoaderNote(msg){ if(loadNote) loadNote.textContent = msg || ''; } if(loadPct){ loadPct.textContent = (label? label+' ' : '') + v + '%'; } }
    function renderLoader3D(){ if(!loaderState.active) return; loaderState.model.rotation.y += 0.06; loaderState.r.render(loaderState.scene, loaderState.cam); }
    function hideLoader(){ if(!loaderState.active) return; loaderEl.style.display = 'none'; if(loaderState.r){ loaderState.r.dispose(); } loader3d.innerHTML=''; loaderState.active=false; setLoaderNote(''); } loader3d.innerHTML=''; loaderState.active=false; }

    // Boot
    applyTimeOfDayTheme(true);
    loadAndBuild();

    // ---- Demo fallback ----
    function buildDemoCity(){
      city.clear(); spawns.clear();
      const rng = (a,b)=> a + Math.random()*(b-a);
      for(let gx=-8; gx<=8; gx++){
        for(let gz=-8; gz<=8; gz++){
          if(Math.random()<0.2) continue;
          const w = rng(20, 60), d = rng(20, 60), h = rng(10, 120);
          const geom = new THREE.BoxGeometry(w, h, d);
          const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(0.6+rng(-0.05,0.05), 0.25, 0.8), roughness:0.95, metalness:0.05, emissive:0xffffff, emissiveIntensity:0.03 });
          const m = new THREE.Mesh(geom, mat);
          m.position.set(gx*90 + rng(-10,10), h/2, gz*90 + rng(-10,10));
          m.userData = { height: h, tags: { name: '' } };
          city.add(m);
        }
      }
      spawnMonsters(10);
      fitCamera();
      applyTimeOfDayTheme(true);
      setStatus('デモモード（オフライン/Overpass不調）');
      hideLoader();
    }
    fallbackBtn?.addEventListener('click', buildDemoCity);
  </script>
</body>
</html>
