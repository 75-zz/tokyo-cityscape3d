<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tokyo 3D — Pastel City Hunt (OSM + Three.js)</title>
  <style>
    :root{
      --bg:#f6f7fb; --ink:#0b0f14; --glass:rgba(255,255,255,.7); --line:rgba(0,0,0,.08);
      --btn:#ffffff; --btn-line:#d7dce6; --accent:#6aa9ff; --accent2:#ff9ecb; --accent3:#88e1a1;
    }
    html, body { margin: 0; height: 100%; overflow: hidden; background: var(--bg); color: var(--ink); }
    #app { position: fixed; inset: 0; }
    #hud { position: fixed; left: 12px; bottom: 12px; color: var(--ink); font: 12px/1.4 system-ui, "Noto Sans JP", sans-serif; background: var(--glass); border: 1px solid var(--line); padding: 8px 10px; border-radius: 10px; user-select: none; backdrop-filter: blur(8px); }
    #ui { position: fixed; right: 12px; top: 12px; display: flex; gap: 8px; flex-wrap: wrap; z-index: 5; }
    #ui button { background:var(--btn); color:var(--ink); border:1px solid var(--btn-line); padding:8px 12px; border-radius:10px; cursor:pointer; font:12px/1.2 system-ui; box-shadow: 0 1px 0 rgba(0,0,0,.03); }
    #ui button:hover{ filter: brightness(0.98); }
    #tooltip { position: fixed; pointer-events:none; color:var(--ink); background:var(--glass); padding:6px 8px; border-radius:8px; font:12px/1.3 system-ui; transform: translate(-50%,-130%); opacity:0; transition:opacity .12s; border:1px solid var(--line); backdrop-filter: blur(8px); }
    #warn { position: fixed; inset: 12px 12px auto 12px; background: var(--glass); color: var(--ink); border: 1px solid var(--line); padding: 10px 12px; border-radius: 12px; font: 12px/1.5 system-ui, "Noto Sans JP", sans-serif; z-index: 6; display:none; backdrop-filter: blur(8px); }
    #warn strong { color:#4c8dff; }

    /* Overlays */
    .overlay{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:10; }
    .sheet{ width:min(560px, 92vw); background:var(--glass); border:1px solid var(--line); border-radius:16px; padding:16px; backdrop-filter: blur(10px); box-shadow: 0 20px 60px rgba(0,0,0,.08); }
    .row{ display:flex; gap:12px; align-items:center; }
    .space{ height:12px; }
    .title{ font: 600 16px/1.2 system-ui, "Noto Sans JP"; }
    .muted{ color:#4b5563; font-size:12px; }
    .btn{ background:var(--btn); border:1px solid var(--btn-line); border-radius:10px; padding:8px 12px; cursor:pointer; }
    .btn.primary{ background:linear-gradient(135deg,var(--accent),var(--accent2)); color:white; border:none; }
    .btn.flat{ background:transparent; border: none; color:#1f2937; text-decoration: underline; }
    .grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(140px,1fr)); gap:12px; }
    .card{ background:var(--btn); border:1px solid var(--btn-line); border-radius:12px; padding:10px; text-align:center; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="app"></div>
  <div id="ui">
    <button data-spot="tokyo">東京駅</button>
    <button data-spot="shinjuku">新宿</button>
    <button data-spot="shibuya">渋谷</button>
    <button data-spot="odaiba">お台場</button>
    <button id="refresh">再取得</button>
    <button id="spawn">新規スポーン</button>
    <button id="dex">図鑑</button>
  </div>
  <div id="hud">Pastel City Hunt｜データ: OpenStreetMap / Overpass API</div>
  <div id="tooltip"></div>
  <div id="warn"></div>

  <!-- Battle Overlay -->
  <div id="battle" class="overlay">
    <div class="sheet">
      <div class="row"><div class="title">バトル開始！</div><div style="flex:1"></div><button class="btn flat" id="closeBattle">閉じる</button></div>
      <div class="space"></div>
      <div class="row">
        <div id="enemyAvatar" style="width:120px;height:120px;border-radius:16px;background:linear-gradient(135deg,var(--accent2),#ffd6e8);"></div>
        <div style="flex:1">
          <div><strong id="enemyName">???</strong></div>
          <div class="muted">HP: <span id="enemyHP">--</span></div>
          <div class="space"></div>
          <div class="row">
            <button class="btn primary" id="attackBtn">こうげき</button>
            <button class="btn" id="runBtn">にげる</button>
          </div>
        </div>
      </div>
      <div class="space"></div>
      <div class="muted" id="battleLog">…</div>
    </div>
  </div>

  <!-- Result Overlay -->
  <div id="result" class="overlay">
    <div class="sheet" style="text-align:center">
      <div class="title">GET!!</div>
      <div class="space"></div>
      <div id="resultAvatar" style="width:160px;height:160px;margin:0 auto;border-radius:18px;background:linear-gradient(135deg,var(--accent3),#d2f5dd);"></div>
      <div class="space"></div>
      <div><strong id="resultName">---</strong></div>
      <div class="space"></div>
      <button class="btn primary" id="keepBtn">図鑑に登録</button>
      <button class="btn" id="continueBtn">つづける</button>
    </div>
  </div>

  <!-- Dex Overlay -->
  <div id="dexOverlay" class="overlay">
    <div class="sheet">
      <div class="row"><div class="title">図鑑</div><div style="flex:1"></div><button class="btn flat" id="closeDex">閉じる</button></div>
      <div class="space"></div>
      <div id="dexGrid" class="grid"></div>
    </div>
  </div>

  <script>
    // 注意喚起
    (function(){
      const warn = document.getElementById('warn');
      const importMapSupported = ('supports' in HTMLScriptElement && HTMLScriptElement.supports('importmap'));
      let msgs = [];
      if (location.protocol === 'file:') {
        msgs.push('現在 <strong>file://</strong> で開いています。環境によっては動作しないことがあります。<br>うまくいかない場合は、<code>python -m http.server</code> 等で http://localhost:8000 から開いてください。');
      }
      if (!importMapSupported) msgs.push('このブラウザは <strong>importmap</strong> に対応していない可能性があります。最新ブラウザを推奨。');
      msgs.push('このアプリは <strong>インターネット接続</strong> と <strong>Overpass API</strong> が必要です。');
      if (msgs.length) { warn.innerHTML = msgs.join('<hr style="border:none;border-top:1px solid var(--line);margin:8px 0">'); warn.style.display='block'; setTimeout(()=>warn.style.display='none', 8000); }
    })();
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // ---- Config ----
    const RADIUS_M = 800; // OSMの取得半径
    const CENTER_PRESETS = {
      tokyo:   [139.767125, 35.681236], // 東京駅
      shinjuku:[139.700556, 35.689722],
      shibuya: [139.702148, 35.659516],
      odaiba:  [139.775,    35.625]
    };
    let center = CENTER_PRESETS.tokyo.slice();

    // モンスター定義（IPを避けたオリジナル）
    const MONS = [
      { key:'fluffin', name:'フラッフィン', color:'#ffd1e6', power:[8,14] },
      { key:'sparkid', name:'スパーキッド', color:'#cfe6ff', power:[10,16] },
      { key:'mossie',  name:'モッシー',     color:'#dff6df', power:[7,12] },
      { key:'embero',  name:'エンベロ',     color:'#ffe3c3', power:[9,15] },
      { key:'glacio',  name:'グラシオ',     color:'#e6f3ff', power:[11,17] }
    ];

    // ---- Three.js setup ----
    const container = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    // パステルの空
    const bgGrad = new THREE.Color('#f6f7fb');
    scene.background = bgGrad;

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 8000);
    camera.position.set(0, 540, 1100);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.minDistance = 50;
    controls.maxDistance = 4000;

    // ライトもパステル寄り
    scene.add(new THREE.AmbientLight(0xffffff, 0.9));
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(800, 1500, 600);
    scene.add(sun);

    // ground（明るめ）
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(4000, 4000), new THREE.MeshStandardMaterial({ color: 0xf0f4ff, roughness: 1 }));
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    // 柔らかいグリッド
    const grid = new THREE.GridHelper(4000, 80, 0xbed2ff, 0xdee7ff);
    grid.position.y = 0.02; scene.add(grid);

    const city = new THREE.Group(); scene.add(city);
    const spawns = new THREE.Group(); scene.add(spawns);

    // Tooltip & raycaster
    const tooltip = document.getElementById('tooltip');
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // ---- Utils: WebMercator ----
    const DEG2RAD = Math.PI / 180; const R = 6378137;
    function lonLatToMeters(lon, lat){ const x = R * lon * DEG2RAD; const y = R * Math.log(Math.tan(Math.PI/4 + (lat*DEG2RAD)/2)); return [x, y]; }
    function localXY(lon, lat, originLon, originLat){ const [ox, oy] = lonLatToMeters(originLon, originLat); const [x, y] = lonLatToMeters(lon, lat); return [x - ox, -(y - oy)]; }

    // ---- Overpass fetch ----
    async function fetchBuildings(lon, lat, radiusMeters){
      const dLat = (radiusMeters / 111320);
      const dLon = radiusMeters / (111320 * Math.cos(lat * DEG2RAD));
      const s = lat - dLat, w = lon - dLon, n = lat + dLat, e = lon + dLon;
      const query = `\n[out:json][timeout:25];\n(\n  way["building"](${s},${w},${n},${e});\n  relation["building"](${s},${w},${n},${e});\n);\nout body;\n>;\nout skel qt;`;
      const url = 'https://overpass-api.de/api/interpreter';
      const res = await fetch(url, { method:'POST', body: query, headers: { 'Content-Type': 'text/plain' } });
      if(!res.ok) throw new Error('Overpass API error ' + res.status);
      return res.json();
    }

    // ---- Build meshes from OSM ----
    function buildCityFromOSM(osm, originLon, originLat){
      city.clear(); spawns.clear();
      const nodes = new Map(); const ways = new Map();
      for(const el of osm.elements){ if(el.type === 'node') nodes.set(el.id, el); if(el.type === 'way') ways.set(el.id, el); }
      const palette = ['#cfe0ff','#d8f0ff','#ffe7f3','#e7ffef','#fff5cc'];

      function heightFromTags(tags){
        if(!tags) return 16 + Math.random()*48;
        if(tags.height){ const m = String(tags.height).match(/([0-9.]+)/); if(m) return parseFloat(m[1]); }
        if(tags["building:levels"]) return parseFloat(tags["building:levels"]) * 3 + 3;
        return 12 + Math.random()*40;
      }

      function addFootprint(nodeIds, tags){
        if(nodeIds.length < 3) return;
        const pts = [];
        for(const nid of nodeIds){ const nd = nodes.get(nid); if(!nd) return; pts.push(localXY(nd.lon, nd.lat, center[0], center[1])); }
        const first = pts[0], last = pts[pts.length-1];
        if(first[0] !== last[0] || first[1] !== last[1]) pts.push(first);
        const shape = new THREE.Shape(); shape.moveTo(pts[0][0], pts[0][1]); for(let i=1;i<pts.length;i++) shape.lineTo(pts[i][0], pts[i][1]);
        const h = heightFromTags(tags);
        const geom = new THREE.ExtrudeGeometry(shape, { depth: h, bevelEnabled: false });
        geom.rotateX(-Math.PI/2); geom.computeVertexNormals();
        const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(palette[(Math.random()*palette.length)|0]), metalness: 0.05, roughness: 0.9, emissive: 0xffffff, emissiveIntensity: 0.05 });
        const mesh = new THREE.Mesh(geom, mat); mesh.position.y = 0; mesh.castShadow = false; mesh.receiveShadow = false; mesh.userData = { tags, height: h };
        city.add(mesh);
      }

      for(const el of osm.elements){ if(el.type === 'way' && el.tags && el.tags.building){ addFootprint(el.nodes, el.tags); } }

      // スポーンを生成
      spawnMonsters();
    }

    // ---- Monster models ----
    function makeMonsterModel(mon){
      const g = new THREE.Group();
      g.userData.mon = mon;
      const mainMat = new THREE.MeshToonMaterial({ color: new THREE.Color(mon.color) });
      const white = new THREE.MeshToonMaterial({ color: 0xffffff });
      const dark = new THREE.MeshToonMaterial({ color: 0x1f2937 });

      const addEye = (x,y,z,s=1)=>{
        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.9*s, 12, 12), dark);
        eye.position.set(x,y,z); g.add(eye);
      };

      switch(mon.key){
        case 'fluffin': {
          const body = new THREE.Mesh(new THREE.SphereGeometry(8, 24, 24), mainMat);
          const earL = new THREE.Mesh(new THREE.ConeGeometry(3.2, 5.5, 12), mainMat);
          const earR = earL.clone();
          earL.material.side = THREE.DoubleSide; earR.material.side = THREE.DoubleSide;
          earL.position.set(-4, 10, 0); earL.rotation.z = 0.2;
          earR.position.set( 4, 10, 0); earR.rotation.z = -0.2;
          addEye(-2.2, 3.2, 7.4); addEye(2.2, 3.2, 7.4);
          g.add(body, earL, earR);
          g.userData.anim = 'float';
          break;
        }
        case 'sparkid': {
          const body = new THREE.Mesh(new THREE.BoxGeometry(12, 9, 10), mainMat);
          const ant = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 7, 10), white);
          const tip = new THREE.Mesh(new THREE.SphereGeometry(1.4, 12, 12), white);
          ant.position.set(0, 7.5, 0); tip.position.set(0, 11.5, 0);
          addEye(-2.8, 2.5, 5.2); addEye(2.8, 2.5, 5.2);
          g.add(body, ant, tip);
          g.userData.parts = { ant, tip };
          g.userData.anim = 'antenna';
          break;
        }
        case 'mossie': {
          const body = new THREE.Mesh(new THREE.SphereGeometry(7.5, 24, 24), mainMat);
          const tail = new THREE.Mesh(new THREE.ConeGeometry(3.2, 6.5, 12), mainMat);
          tail.material.side = THREE.DoubleSide;
          tail.rotation.x = Math.PI; tail.position.set(0, -7, -1);
          const wingL = new THREE.Mesh(new THREE.ConeGeometry(2.2, 8, 12), white);
          const wingR = wingL.clone();
          wingL.material.side = THREE.DoubleSide; wingR.material.side = THREE.DoubleSide;
          wingL.rotation.z =  1.1; wingL.position.set(-7, 2, 0);
          wingR.rotation.z = -1.1; wingR.position.set( 7, 2, 0);
          addEye(-2.1, 2.6, 6.7); addEye(2.1, 2.6, 6.7);
          g.add(body, tail, wingL, wingR);
          g.userData.parts = { wingL, wingR };
          g.userData.anim = 'flap';
          break;
        }
        case 'embero': {
          const body = new THREE.Mesh(new THREE.SphereGeometry(7.5, 24, 24), mainMat);
          const f1 = new THREE.Mesh(new THREE.ConeGeometry(2.2, 7, 8), white);
          const f2 = f1.clone(); const f3 = f1.clone();
          f1.material.side = f2.material.side = f3.material.side = THREE.DoubleSide;
          f1.position.set(0, 9.5, 0);
          f2.position.set(-2.6, 8.8, -1.2); f2.rotation.z = 0.4;
          f3.position.set( 2.6, 8.8, -1.2); f3.rotation.z = -0.4;
          addEye(-2.2, 2.4, 6.7); addEye(2.2, 2.4, 6.7);
          g.add(body, f1, f2, f3);
          g.userData.parts = { f1, f2, f3 };
          g.userData.anim = 'flicker';
          break;
        }
        case 'glacio': {
          const body = new THREE.Mesh(new THREE.IcosahedronGeometry(7.5, 0), mainMat);
          const shard1 = new THREE.Mesh(new THREE.ConeGeometry(2, 6, 6), white);
          const shard2 = shard1.clone();
          shard1.material.side = shard2.material.side = THREE.DoubleSide;
          shard1.position.set(-4, -5, -2); shard1.rotation.x = -0.6;
          shard2.position.set( 4, -5, -2); shard2.rotation.x = -0.6;
          addEye(-2.0, 1.8, 6.8); addEye(2.0, 1.8, 6.8);
          g.add(body, shard1, shard2);
          g.userData.parts = { body };
          g.userData.anim = 'spin';
          break;
        }
      }

      // 足場リング（出現マーカー）
      const ring = new THREE.Mesh(new THREE.TorusGeometry(14, 1.5, 8, 32), new THREE.MeshStandardMaterial({ color: '#ffffff', emissive: 0xffffff, emissiveIntensity: 0.2 }));
      ring.rotation.x = Math.PI/2; g.add(ring);

      // 輪郭線で視認性UP
      const allGeo = new THREE.BufferGeometry();
      const tmp = [];
      g.traverse(obj=>{ if(obj.isMesh){ const eg = new THREE.EdgesGeometry(obj.geometry, 20); tmp.push(new THREE.LineSegments(eg, new THREE.LineBasicMaterial({ color: 0x2f3947, transparent:true, opacity:0.35 }))); } });
      tmp.forEach(ls=>g.add(ls));

      // サイズ感を上げる
      g.scale.set(2.2, 2.2, 2.2);

      return g;
    }

    // ---- Spawns ----
    function spawnMonsters(count = 10){
      spawns.clear();
      const area = 900; // 配置範囲（±area）
      for(let i=0;i<count;i++){
        const mon = MONS[(Math.random()*MONS.length)|0];
        const g = makeMonsterModel(mon);
        const x = (Math.random()-0.5)*2*area;
        const z = (Math.random()-0.5)*2*area;
        const y = getTopHeightAt(x, z) + 6; // 建物の上に乗らないよう、上端+少し浮かせる
        g.position.set(x, y, z);
        g.rotation.y = Math.random()*Math.PI*2;
        g.userData.type = 'spawn';
        spawns.add(g);
      }
    }

    // 建物の真上/地面の高さを取得（最上位の交差点）
    function getTopHeightAt(x, z){
      const rc = new THREE.Raycaster(new THREE.Vector3(x, 5000, z), new THREE.Vector3(0, -1, 0));
      const hits = rc.intersectObjects(city.children, false);
      if(hits.length){ return hits[0].point.y; }
      return 0; // 地面
    }
    }

    // ---- Battle state ----
    const battleEl = document.getElementById('battle');
    const enemyNameEl = document.getElementById('enemyName');
    const enemyHPEl = document.getElementById('enemyHP');
    const enemyAvatarEl = document.getElementById('enemyAvatar');
    const battleLogEl = document.getElementById('battleLog');
    const attackBtn = document.getElementById('attackBtn');
    const runBtn = document.getElementById('runBtn');
    const closeBattle = document.getElementById('closeBattle');

    let currentEnemy = null; let enemyHP = 0; let myHP = 30;

    function openBattle(mon){
      currentEnemy = mon; enemyHP = 20 + Math.floor(Math.random()*15); myHP = 30;
      enemyNameEl.textContent = mon.name; enemyHPEl.textContent = enemyHP;
      enemyAvatarEl.style.background = `linear-gradient(135deg, ${mon.color}, #ffffff)`;
      battleLogEl.textContent = '野生の ' + mon.name + ' があらわれた！';
      battleEl.style.display = 'flex';
    }

    function closeBattleUI(){ battleEl.style.display = 'none'; }

    attackBtn.addEventListener('click', ()=>{
      if(!currentEnemy) return;
      const dmg = randInt(...currentEnemy.power);
      enemyHP = Math.max(0, enemyHP - dmg);
      enemyHPEl.textContent = enemyHP;
      battleLogEl.textContent = `${currentEnemy.name} に ${dmg} ダメージ！`;
      if(enemyHP === 0){ setTimeout(()=> openResult(currentEnemy), 400); battleEl.style.display = 'none'; return; }
      const counter = randInt(3,8); myHP = Math.max(0, myHP - counter);
      battleLogEl.textContent += ` / こうげきをうけた！ (${counter})`;
    });

    runBtn.addEventListener('click', ()=>{ battleLogEl.textContent = 'にげた！'; setTimeout(closeBattleUI, 250); });
    closeBattle.addEventListener('click', closeBattleUI);

    // ---- Result ----
    const resultEl = document.getElementById('result');
    const resultAvatar = document.getElementById('resultAvatar');
    const resultName = document.getElementById('resultName');
    const keepBtn = document.getElementById('keepBtn');
    const continueBtn = document.getElementById('continueBtn');
    let captured = null;

    function openResult(mon){ captured = mon; resultName.textContent = mon.name; resultAvatar.style.background = `linear-gradient(135deg, ${mon.color}, #ffffff)`; resultEl.style.display='flex'; }
    keepBtn.addEventListener('click', ()=>{ if(captured){ addToDex(captured); } resultEl.style.display='none'; });
    continueBtn.addEventListener('click', ()=>{ resultEl.style.display='none'; });

    // ---- Dex (localStorage) ----
    const DEX_KEY = 'pastel_city_dex_v1';
    const dexOverlay = document.getElementById('dexOverlay');
    const dexGrid = document.getElementById('dexGrid');
    const closeDex = document.getElementById('closeDex');
    function loadDex(){ try{ return JSON.parse(localStorage.getItem(DEX_KEY) || '[]'); }catch{ return []; } }
    function saveDex(list){ localStorage.setItem(DEX_KEY, JSON.stringify(list)); }
    function addToDex(mon){ const list = loadDex(); list.push({ key: mon.key, name: mon.name, color: mon.color, ts: Date.now() }); saveDex(list); showDex(); }
    function showDex(){
      const list = loadDex(); dexGrid.innerHTML = '';
      if(list.length===0){ dexGrid.innerHTML = '<div class="muted">まだ何も捕まえていません。</div>'; }
      else{
        for(const it of list){ const d = document.createElement('div'); d.className='card'; d.innerHTML = `<div style="width:96px;height:96px;border-radius:14px;margin:0 auto;background:linear-gradient(135deg, ${it.color}, #ffffff);"></div><div style="height:8px"></div><div><strong>${it.name}</strong></div><div class="muted">${new Date(it.ts).toLocaleString()}</div>`; dexGrid.appendChild(d); }
      }
      dexOverlay.style.display='flex';
    }
    closeDex.addEventListener('click', ()=> dexOverlay.style.display='none');

    document.getElementById('dex').addEventListener('click', showDex);

    // ---- Load & build ----
    async function loadAndBuild(){
      setStatus('OSM建物取得中…');
      try{ const data = await fetchBuildings(center[0], center[1], RADIUS_M); buildCityFromOSM(data, center[0], center[1]); fitCamera(); setStatus('完了: ' + city.children.length + ' 棟 / スポーン: ' + spawns.children.length); }
      catch(err){ console.error(err); setStatus('取得失敗: ' + err.message); }
    }

    function fitCamera(){ controls.target.set(0,0,0); camera.position.set(0, 540, 1100); controls.update(); }

    document.getElementById('ui').addEventListener('click', (e)=>{
      const btn = e.target.closest('button'); if(!btn) return;
      if(btn.id === 'refresh'){ loadAndBuild(); return; }
      if(btn.id === 'spawn'){ spawnMonsters(10); setStatus('スポーン作成: ' + spawns.children.length); return; }
      if(btn.dataset.spot){ const key = btn.dataset.spot; if(CENTER_PRESETS[key]){ center = CENTER_PRESETS[key].slice(); loadAndBuild(); } }
    });

    function findSpawnGroup(obj){
      let cur = obj; while(cur && cur.parent){ if(cur.userData && cur.userData.type==='spawn') return cur; cur = cur.parent; } return null;
    }

    // Click interactions (buildings & spawns)
    addEventListener('pointerdown', (e)=>{
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left)/rect.width)*2 - 1; mouse.y = -((e.clientY - rect.top)/rect.height)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hitsSpawn = raycaster.intersectObjects(spawns.children, true);
      if(hitsSpawn.length){ const root = findSpawnGroup(hitsSpawn[0].object); if(root){ openBattle(root.userData.mon); } return; }
      const hitB = raycaster.intersectObjects(city.children, false)[0];
      if(hitB){ const tags = hitB.object.userData.tags || {}; const h = Math.round(hitB.object.userData.height); showTip(e.clientX, e.clientY, `${tags.name? tags.name + ' / ' : ''}高さ: ${h}m`); } else { hideTip(); }
    });

    function showTip(x,y, text){ const t = document.getElementById('tooltip'); t.textContent = text; t.style.left=x+'px'; t.style.top=y+'px'; t.style.opacity=1; }
    function hideTip(){ document.getElementById('tooltip').style.opacity = 0; }

    // Status
    const hud = document.getElementById('hud');
    function setStatus(msg){ hud.textContent = `Pastel City Hunt｜${msg}`; }

    // Resize
    addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    // Animate
    ;(function loop(){
      requestAnimationFrame(loop);
      const t = performance.now()/1000;
      spawns.children.forEach((g,i)=>{
        // 共通のふわふわ
        g.position.y = 12 + Math.sin(t*1.6 + i)*1.5;
        g.rotation.y += 0.01;
        // 種族別アニメ
        const mon = g.userData.mon; const parts = g.userData.parts||{};
        switch(mon?.key){
          case 'mossie': {
            if(parts.wingL && parts.wingR){ const a = Math.sin(t*6 + i)*0.5 + 0.6; parts.wingL.rotation.z =  1.1 + a*0.25; parts.wingR.rotation.z = -1.1 - a*0.25; }
            break;
          }
          case 'sparkid': {
            if(parts.ant && parts.tip){ parts.ant.rotation.z = Math.sin(t*4 + i)*0.15; parts.tip.position.y = 11.5 + Math.sin(t*3 + i)*0.4; }
            break;
          }
          case 'embero': {
            const p = parts; if(p && p.f1){ const k = Math.sin(t*5 + i)*0.08; p.f1.rotation.z = k; if(p.f2) p.f2.rotation.z = 0.4 + k; if(p.f3) p.f3.rotation.z = -0.4 - k; }
            break;
          }
          case 'glacio': {
            const p = parts; if(p && p.body){ p.body.rotation.y += 0.01; }
            break;
          }
        }
            break;
          }
          case 'sparkid': {
            // アンテナをぷるぷる
            break;
          }
          case 'embero': {
            // 炎コーンを微振動（見た目だけ）
            break;
          }
          case 'glacio': {
            // クリスタルはゆっくりスピン
            break;
          }
        }
      });
      controls.update(); renderer.render(scene, camera);
    })();

    // Helpers
    function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

    // Boot
    loadAndBuild();
  </script>
</body>
</html>
